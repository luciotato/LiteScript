//Generated by LiteScript compiler v0.8.9, source: interfaces/PMREX.lite.md
// -----------
// Module Init
// -----------
//PMREX is composed of three functions
//which are simple but enough to tokenize a stream of chars (unicode)

//By using this functions we can avoid Regex Patterns to tokenize

    //    public function whileRanges(chunk:string, rangesStr:string) returns string
    // ---------------------------
    function whileRanges(chunk, rangesStr){

//whileRanges, advance while the char is in the ranges specified.
//will return string up to first char not in range, or entire string if all chars are in ranges
//e.g.: whileRanges("123ABC","0-9") will return "123"
//e.g.: whileRanges("123ABC","0-9A-Z") will return "123ABC" because all chars are in range

        //var len = chunk.length
        var len = chunk.length;

        //normalize ranges
        //var ranges = parseRanges(rangesStr)
        var ranges = parseRanges(rangesStr);

        //advance while in any of the ranges
        //var inx=0
        var inx = 0;
        //do while inx<len
        while(inx < len){
            //var ch = chunk.charAt(inx)
            var ch = chunk.charAt(inx);
            //var isIn=false
            var isIn = false;
            //check all ranges
            //for r=0 to ranges.length-1, r+=2
            var _end5=ranges.length - 1;
            for( var r=0; r<=_end5; r += 2) {
                //if ch>=ranges.charAt(r) and ch<=ranges.charAt(r+1)
                if (ch >= ranges.charAt(r) && ch <= ranges.charAt(r + 1)) {
                
                    //isIn=true
                    isIn = true;
                    //break
                    break;
                };
            };// end for r
            //end for
            //if not isIn, break
            
            //if not isIn, break
            if (!(isIn)) {break};
            //inx++
            inx++;
        };// end loop

        //return chunk.slice(0,inx)
        return chunk.slice(0, inx);
    }
    // export
    module.exports.whileRanges = whileRanges;


    //    public function untilRanges(chunk:string, rangesStr:string) returns string
    // ---------------------------
    function untilRanges(chunk, rangesStr){

//untilRanges: advance from start, *until* a char is in one of the specified ranges.
//will return string up to first char *in range* or entire string if there's no match
//e.g.: findRanges("123ABC","A-Z") will return "123"
//e.g.: findRanges("123ABC","C-FJ-L") will return "123AB"

        //var len = chunk.length
        var len = chunk.length;

        //normalize ranges
        //var ranges = parseRanges(rangesStr)
        var ranges = parseRanges(rangesStr);

        //advance until match
        //var inx=0
        var inx = 0;
        //do while inx<len
        while(inx < len){
            //var ch = chunk.charAt(inx)
            var ch = chunk.charAt(inx);
            //check all ranges
            //for r=0 to ranges.length-1, r+=2
            var _end6=ranges.length - 1;
            for( var r=0; r<=_end6; r += 2) {
                //if ch>=ranges.charAt(r) and ch<=ranges.charAt(r+1)
                if (ch >= ranges.charAt(r) && ch <= ranges.charAt(r + 1)) {
                
                    //return chunk.slice(0,inx)
                    return chunk.slice(0, inx);
                };
            };// end for r
            //end for
            //inx++
            
            //inx++
            inx++;
        };// end loop

        //return chunk.slice(0,inx)
        return chunk.slice(0, inx);
    }
    // export
    module.exports.untilRanges = untilRanges;

    //    helper function parseRanges(rangesStr:string) returns string
    // ---------------------------
    function parseRanges(rangesStr){

//Range examples:

//* "1-9" means all chars between 1 and 9 (inclusive)
//* "1-9J-Z" means all chars between 1 and 9 or between "J" and "Z"
//* "1-9JNW" means all chars between 1 and 9, a "J" a "N" or a "W"

//This function returns a normalized range string without "-"
//and composed always from ranges:
//
//    "1-9" => "19"
//    "1-9J-Z" => "19JZ"
//    "1-9JNW" => "19JJNNWW"

        //var result = ""
        var result = "";

        //parse ranges in array [[from,to],[from,to]...]
        //var ch:string
        var ch = undefined;
        //var inx=0
        var inx = 0;
        //while inx<rangesStr.length
        while(inx < rangesStr.length){
            //ch = rangesStr.charAt(inx)
            ch = rangesStr.charAt(inx);
            //result &= ch
            result += ch;
            //if rangesStr.charAt(inx+1) is '-'
            if (rangesStr.charAt(inx + 1) === '-') {
            
                //inx++
                inx++;
                //result &= rangesStr.charAt(inx+1)
                result += rangesStr.charAt(inx + 1);
            }
            //if rangesStr.charAt(inx+1) is '-'
            
            else {
                //result &= ch
                result += ch;
            };
            //inx++
            inx++;
        };// end loop

        //return result
        return result;
    };


    //    public function whileUnescaped(chunk:string,endChar:string) returns string
    // ---------------------------
    function whileUnescaped(chunk, endChar){

//advance until unescaped endChar
//return string up to endChar (excluded)

        //var pos = 0
        var pos = 0;
        //do
        while(true){
            //var inx = chunk.indexOf(endChar,pos)
            var inx = chunk.indexOf(endChar, pos);

            //if inx is -1, fail with 'missing closing quote-char: #{endChar} ' // closer not found
            if (inx === -1) {throw new Error('missing closing quote-char: ' + endChar + ' ')};

            //if inx>0 and chunk.charAt(inx-1) is '\\' #escaped
            if (inx > 0 && chunk.charAt(inx - 1) === '\\') {
            

                //var countEscape=1
                var countEscape = 1;
                //while inx>countEscape and chunk.charAt(inx-1-countEscape) is '\\' #escaped-escape
                while(inx > countEscape && chunk.charAt(inx - 1 - countEscape) === '\\'){
                        //countEscape++
                        countEscape++;
                };// end loop

                //if countEscape % 2 is 0 //even, means escaped-escape, means: not escaped
                if (countEscape % 2 === 0) {
                
                    //break    //we found an unescaped quote
                    break;
                }
                //if countEscape % 2 is 0 //even, means escaped-escape, means: not escaped
                
                else {
                    //pos=inx+1 //odd means escaped quote, so it's not closing quote
                    pos = inx + 1;
                };
            }
            //if inx>0 and chunk.charAt(inx-1) is '\\' #escaped
            
            else {
                //found unescaped
                //break
                break;
            };
        };// end loop
        //return chunk.slice(0,inx)
        return chunk.slice(0, inx);
    }
    // export
    module.exports.whileUnescaped = whileUnescaped;

    //    public function quotedContent(chunk:string) returns string
    // ---------------------------
    function quotedContent(chunk){

//return the string up to the matching quote, excluding both
//Note: chunk[0] MUST be the openinig quote, either single-quote or double-quote

        //if no chunk.charAt(0) in '/"\'', throw "chunk.charAt(0) MUST be the openinig quote-char"
        if (!('/"\''.indexOf(chunk.charAt(0))>=0)) {throw "chunk.charAt(0) MUST be the openinig quote-char"};
        //return whileUnescaped(chunk.slice(1),chunk.charAt(0))
        return whileUnescaped(chunk.slice(1), chunk.charAt(0));
    }
    // export
    module.exports.quotedContent = quotedContent;
// -----------
// Module code
// -----------
// end of module
//# sourceMappingURL=PMREX.js.map
