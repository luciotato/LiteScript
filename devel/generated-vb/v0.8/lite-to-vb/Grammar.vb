'Generated by LiteScript compiler v0.8.9, source: Grammar.lite.md
' -----------
Module Grammar
' -----------
'==================

'The LiteScript Grammar is based on [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)
'*with extensions*.

'Grammar Meta-Syntax
'-------------------

'Each Grammar class, contains a 'grammar definition' as reference.
'The meta-syntax for the grammar definitions is an extended form of
'[Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)

'The differences with classic PEG are:
'* instead of `Symbol <- definition`, we use `Symbol: definition` (colon instead of arrow)
'* we use `[Symbol]` for optional symbols instead of `Symbol?` (brackets also groups symbols, the entire group is optional)
'* symbols upper/lower case has meaning
'* we add `(Symbol,)` for `comma separated List of` as a powerful syntax option

'Meta-Syntax Examples:

'`function`         : all-lowercase means the literal word: "function"<br>
'`":"`              : literal symbols are quoted<br>
'`ReturnStatement`  : CamelCase is reserved for composed, non-terminal symbol<br>

'`IDENTIFIER`,`OPER` : all-uppercase denotes a entire class of symbols<br>
'`NEWLINE`,`EOF`     : or special unprintable characters<br>

'`[to]`               : Optional symbols are enclosed in brackets<br>
'`(var|let)`          : The vertical bar represents ordered alternatives<br>

'`(Oper Operand)`     : Parentheses groups symbols<br>
'`(Oper Operand)*`    : Asterisk after a group `()*` means the group can repeat (meaning one or more)<br>
'`[Oper Operand]*`    : Asterisk after a optional group `[]*` means *zero* or more of the group.<br>

'`[Expression,]` : means: "optional comma separated list of Expressions".<br>
'`Body: (Statement;)` : means "Body is a semicolon-separated list of statements".<br>

'Full Meta-Syntax Example:

'`PrintStatement: print [Expression,]`

'It reads: composed symbol `PrintStatement` is conformed by the word `print` followed by
'an _optional_ comma-separated list of `Expression`

'###More on comma-separated lists

'Let's analyze the example: `PrintStatement: print [Expression,]`

'`[Expression,]` means *optional* **comma "Separated List"** of Expressions.
'Since the comma is inside a **[ ]** group, it means the entire list is optional.

'Another example:

'`VariableDecl: IDENTIFIER ["=" Expression]`

'`VarStatement: var (VariableDecl,)`

'It reads: composed symbol `VarStatement` is conformed by the word `var` followed by
'a comma-separated list of `VariableDecl` (at least one)

'The construction `(VariableDecl,)` means: **comma "Separated List"** of `VariableDecl`

'Since the comma is inside a **( )** group, it means _at least one VariableDecl_ is required.

'###"Free form": separated lists are flexible

'Separated lists can be presented in "free-form" mode.
'In "free-form", the list is indented, and commas(or semicolons) are optional.

'Example:

'For the grammar: `FunctionCall: IDENTIFIER '(' [Expression,] ')'`

'This is a valid text: `console.log(1,2,3,"Foo")`

'and the following is *also* a valid text:
'
'
'    console.log
'        1
'        2
'        3
'        "Foo"
'


'Grammar Implementation
'-----------------------

'The LiteScript Grammar is defined as `classes`, one class for each rule.

'The `.parse()` method of each class will try the grammar rule on the token stream and:

'- If all tokens match, it will populate the node consuming the tokens. (success)
'- On a token mismatch, it will raise a 'parse failed' exception.

'When a 'parse failed' exception is raised, other classes/rules can be tried.
'If no class parses ok, a compiler error is emitted and compilation is aborted.

'if the exception is *before* the class has determined this was the right rule,
'it is a soft-error and other rules can be tried on the token stream.

'if the exception is *after* the class has determined this was the right rule
'(if the AST node was 'locked'), it is a hard-error and compilation is aborted.

'The `ASTBase` module defines the base class for all grammar classes along with
'utility methods to parse _required_ tokens and parse _optional_ ones.


'### Dependencies

    'import ASTBase, logger, UniqueID
    'var ASTBase = require('./ASTBase.vb');
    'var logger = require('./lib/logger.vb');
    'var UniqueID = require('./lib/UniqueID.vb');

    'shim import Map, PMREX
    'var Map = require('./interfaces/Map.vb');
    'var PMREX = require('./interfaces/PMREX.vb');

'Reserved Words
'---------------

'Words that are reserved in LiteScript and cannot be used as variable or function names
'(There are no restrictions to object property names)

    'var RESERVED_WORDS = [
        ''namespace'
        ''function','async'
        ''class','method'
        ''if','then','else','switch','when','case','end'
        ''null','true','false','undefined'
        ''and','or','but','no','not','has','hasnt','property','properties'
        ''new','is','isnt','prototype'
        ''do','loop','while','until','for','to','break','continue'
        ''return','try','catch','throw','raise','fail','exception','finally'
        ''with','arguments','in','instanceof','typeof'
        ''var','let','default','delete','interface','implements','yield'
        ''like','this','super'
        ''export','only','compiler','compile','debugger'
        '//-----------------
        '// "compile-to-c" reserved words
        ''char','short','long','int','unsigned','void','NULL','bool','assert'
        ']
    Dim RESERVED_WORDS = new ArrayList From {"namespace", "function", "async", "class", "method", "if", "then", "else", "switch", "when", "case", "end", "null", "true", "false", "undefined", "and", "or", "but", "no", "not", "has", "hasnt", "property", "properties", "new", "is", "isnt", "prototype", "do", "loop", "while", "until", "for", "to", "break", "continue", "return", "try", "catch", "throw", "raise", "fail", "exception", "finally", "with", "arguments", "in", "instanceof", "typeof", "var", "let", "default", "delete", "interface", "implements", "yield", "like", "this", "super", "export", "only", "compiler", "compile", "debugger", "char", "short", "long", "int", "unsigned", "void", "NULL", "bool", "assert"}

'Operators precedence
'--------------------

'The order of symbols here determines operators precedence

    'var operatorsPrecedence = [
      ''++','--', 'unary -', 'unary +', 'bitnot' ,'bitand', 'bitor', 'bitxor'
      ','>>','<<'
      ','new','type of','instance of','has property'
      ','*','/','%','+','-','&'
      ','into','in'
      ','>','<','>=','<=','is','<>','!==','like'
      ','no','not','and','but','or'
      ','?',':'
    ']
    Dim operatorsPrecedence = new ArrayList From {"++", "--", "unary -", "unary +", "bitnot", "bitand", "bitor", "bitxor", ">>", "<<", "new", "type of", "instance of", "has property", "*", "/", "%", "+", "-", "&", "into", "in", ">", "<", ">=", "<=", "is", "<>", "!==", "like", "no", "not", "and", "but", "or", "?", ":"}

'--------------------------

'LiteScript Grammar - AST Classes
'================================
'This file is code and documentation, you'll find a class
'for each syntax construction the compiler accepts.

    '    export class PrintStatement extends ASTBase
    ' constructor
    Class PrintStatement
    Inherits ASTBase
        Public Property args as Array' mainType: Array  ' itemType: Expression
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'print'
        Me.req("print")

'At this point we lock because it is definitely a `print` statement. Failure to parse the expression
'from this point is a syntax error.

        '.lock()
        Me.lock()

'After the word 'print' we require an optional comma-separated list of 'Expression'

        '.args = this.optSeparatedList(Expression,",")
        Me.args = Me.optSeparatedList(Expression, ",")
      end function
    
    end class 'PrintStatement


    '    export class VariableDecl extends ASTBase
    ' constructor
    Class VariableDecl
    Inherits ASTBase
        Public Property assignedValue as Expression' mainType: Expression  
      
          Public Property required as Boolean' mainType: Boolean  
      
          Public Property aliasVarRef as VariableRef' mainType: VariableRef  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '// accept '...' to denote a variadic function
        'if .lexer.token.value is '...' and .parent instance of FunctionParameters
        if Me.lexer.token.value = "..." AndAlso TypeOf Me.parent is FunctionParameters Then
        
            '.name = .req('...')
            Me.name = Me.req("...")
            'return
            return
        
        End if

        '.name = .req('IDENTIFIER')
        Me.name = Me.req("IDENTIFIER")
        '.lock()
        Me.lock()

        'if .parent instance of VarStatement
        if TypeOf Me.parent is VarStatement AndAlso RESERVED_WORDS.Contains(Me.name) Then
        
                '.sayErr '"#{.name}" is a reserved word'
                Me.sayErr(""" + Me.name + "" is a reserved word")
        
        End if

'optional type annotation &
'optional assigned value

        'var parseFreeForm
        Dim parseFreeForm = Nothing

        'if .opt(':')
        if Me.opt(":") Then
        
            '.type = .req(TypeDeclaration)
            Me.type = Me.req(TypeDeclaration)
            'if .opt('required'), .required = true
            if Me.opt("required") Then Me.required = true
        
        End if

        'if .opt('=')
        if Me.opt("=") Then
        

            'if .lexer.token.type is 'NEWLINE' #dangling assignment "="[NEWLINE]
            if Me.lexer.token.type = "NEWLINE" Then
            
                'parseFreeForm=true
                parseFreeForm = true
            
            'if .lexer.token.type is 'NEWLINE' #dangling assignment "="[NEWLINE]
            
            elseif Me.lexer.token.value = "map" Then
            
                '.req 'map'
                Me.req("map")
                '.type='Map'
                Me.type = "Map"
                '.isMap = true
                Me.isMap = true
                'parseFreeForm=true
                parseFreeForm = true
            
            'else if .lexer.token.value is 'map' #literal map creation "x = map"[NEWLINE]name:value[NEWLINE]name=value...
            
            else
            
                'if .lexer.interfaceMode //assignment in interfaces => declare var alias. as in: `var $=jQuery`
                if Me.lexer.interfaceMode Then
                
                    '.aliasVarRef = .req(VariableRef)
                    Me.aliasVarRef = Me.req(VariableRef)
                
                'if .lexer.interfaceMode //assignment in interfaces => declare var alias. as in: `var $=jQuery`
                
                else
                
                    '.assignedValue = .req(Expression)
                    Me.assignedValue = Me.req(Expression)
                
                End if
                
            
            End if
            End if
            
        
        End if

        'if parseFreeForm #dangling assignment, parse a free-form object literal as assigned value
        if parseFreeForm Then
        
            '.assignedValue   = .req(FreeObjectLiteral)
            Me.assignedValue = Me.req(FreeObjectLiteral)
        
        End if

'if was declared with type Map, (freeform or not) initialization literal is also map.
'e.g: `var myMap: map string to any = {}`. Because of type:Map,
'the expression `{}` gets compiled as `new Map().fromObject({})`

        'if .isMap and .assignedValue
        if Me.isMap AndAlso Me.assignedValue Then
        
            '.assignedValue.type='Map'
            Me.assignedValue.type = "Map"
            '.assignedValue.isMap = true
            Me.assignedValue.isMap = true
        
        End if
        
      end function
    
    end class 'VariableDecl


'##FreeObjectLiteral and Free-Form Separated List

'In *free-form* mode, each item stands on its own line, and separators (comma/semicolon)
'are optional, and can appear after or before the NEWLINE.

'For example, given the previous example: **VarStatement: (IDENTIFIER ["=" Expression] ,)**,
'all the following constructions are equivalent and valid in LiteScript:

'Examples:
'
'
'    //standard js
'    var a = {prop1:30 prop2: { prop2_1:19, prop2_2:71} arr:["Jan","Feb","Mar"]}
'
'    //LiteScript: mixed freeForm and comma separated
'    var a =
'        prop1: 30
'        prop2:
'          prop2_1: 19, prop2_2: 71
'        arr: [ "Jan",
'              "Feb", "Mar"]
'
'    //LiteScript: in freeForm, commas are optional
'    var a =
'        prop1: 30
'        prop2:
'          prop2_1: 19,
'          prop2_2: 71,
'        arr: [
'            "Jan",
'            "Feb"
'            "Mar"
'            ]
'

'##More about comma separated lists

'The examples above only show Object and List Expressions,
'but *you can use free-form mode (multiple lines with the same indent)*,
'*everywhere a comma separated list of items apply.*

'The previous examples were for:

'* Literal Object expression<br>
  'because a Literal Object expression is:<br>
  '"{" + a comma separated list of Item:Value pairs + "}"

'and
'* Literal Array expression<br>
  'because a Literal Array expression is<br>
  '"[" + a comma separated list of expressions + "]"

'But the free-form option also applies for:

'* Function parameters declaration<br>
  'because Function parameters declaration is:<br>
  '"(" + a comma separated list of paramter names + ")"

'* Arguments, for any function call<br>
  'because function call arguments are:<br>
  '"(" + a comma separated list of expressions + ")"

'* Variables declaration<br>
  'because variables declaration is:<br>
  ''var' + a comma separated list of: IDENTIFIER ["=" Expression]

'Examples:
'
'
'  js:
'
'    Console.log(title,subtitle,line1,line2,value,recommendation)
'
'  LiteScript available variations:
'
'    print title,subtitle,
'          line1,line2,
'          value,recommendation
'
'    print
'      title
'      subtitle
'      line1
'      line2
'      value
'      recommendation
'
'  js:
'
'    var a=10, b=20, c=30,
'        d=40;
'
'    function complexFn( 10, 4, 'sample'
'       'see 1',
'       2+2,
'       null ){
'      ...function body...
'    };
'
'  LiteScript:
'
'    var
'      a=10,b=20
'      c=30,d=40
'
'    function complexFn(
'      10       # determines something important to this function
'      4        # do not pass nulll to this
'      'sample' # this is original data
'      'see 1'  # note param
'      2+2      # useful tip
'      null     # reserved for extensions ;)
'      )
'      ...function body...

    '    export helper class VarDeclList extends ASTBase
    ' constructor
    Class VarDeclList
    Inherits ASTBase
        Public Property list as Array' mainType: Array  ' itemType: VariableDecl
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parseList ()
        '.list = .reqSeparatedList(VariableDecl,",")
        Me.list = Me.reqSeparatedList(VariableDecl, ",")
      end function
      ' ---------------------------
      Public Function getNames ()
        'var result=[]
        Dim result = new ArrayList
        'for each varDecl in .list
        For Each varDecl in Me.list
        
            'result.push varDecl.name
            result.push(varDecl.name)
        Next'  each in Me.list
        'return result
        return result
      end function
    
    end class 'VarDeclList


    '    export class VarStatement extends VarDeclList
    ' constructor
    Class VarStatement
    Inherits VarDeclList
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'var','let'
        Me.req("var", "let")
        '.lock
        Me.lock()
        '.parseList
        Me.parseList()
      end function
    
    end class 'VarStatement


    '    export class FunctionParameters extends VarDeclList
    ' constructor
    Class FunctionParameters
    Inherits VarDeclList
        Public Property variadic as Boolean' mainType: Boolean  
      =true
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.list=[]
        Me.list = new ArrayList

        'if .lexer.token.value is "returns"
        if Me.lexer.token.value = "returns" OrElse new ArrayList From {"NEWLINE", "EOF", "SPACE_BRACKET"}
            .Contains(Me.lexer.token.type) Then
        
                'return // assume no specific parameters definitions
                return
        
        End if

'if we define a list of specific parameters, fuction is no longer variadic

        '.lock
        Me.lock()
        '.variadic = false
        Me.variadic = false

        'if .opt("(") into var starterParen // list of parameters ()-enclosed
        Dim starterParen as Object
        if Assign(starterParen,Me.opt("(")) Then
        
            '.list = .optSeparatedList(VariableDecl,",",")")
            Me.list = Me.optSeparatedList(VariableDecl, ",", ")")
        
        'if .opt("(") into var starterParen // list of parameters ()-enclosed
        
        else
        
            '.list = .reqSeparatedList(VariableDecl,",") //require at least one
            Me.list = Me.reqSeparatedList(VariableDecl, ",")
        
        End if

'check if we've parsed "..." ellipsis in the parameters list.
'ellipsis are valid as "last parameter", and restores the "variadic" flag

        'for each inx,item in .list
        Dim inx as Integer =0
        For Each item in Me.list
        
            'if item.name is '...'
            if item.name = "..." Then
            
                'if inx<.list.length-1
                if inx < Me.list.length - 1 Then
                
                    '.sayErr "variadic indicator: '...' is valid only as last parameter"
                    Me.sayErr("variadic indicator: '...' is valid only as last parameter")
                
                'if inx<.list.length-1
                
                else
                
                  '.list.pop //remove "..."
                  Me.list.pop()
                  '.variadic = true
                  Me.variadic = true
                  'break
                  break
                
                End if
                
            
            End if
            
        Next'  each in Me.list
        
      end function
    
    end class 'FunctionParameters

    '    export class PropertiesDeclaration extends VarDeclList
    ' constructor
    Class PropertiesDeclaration
    Inherits VarDeclList
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'properties'
        Me.req("properties")
        '.lock
        Me.lock()
        '.parseList
        Me.parseList()
      end function
    
    end class 'PropertiesDeclaration


    '    export class WithStatement extends ASTBase
    ' constructor
    Class WithStatement
    Inherits ASTBase
        Public Property varRef as Object
          Public Property body as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'with'
        Me.req("with")
        '.lock()
        Me.lock()
        '.name = UniqueID.getVarName('with')  #unique 'with' storage var name
        Me.name = UniqueID.getVarName("with")
        '.varRef = .req(VariableRef)
        Me.varRef = Me.req(VariableRef)
        '.body = .req(Body)
        Me.body = Me.req(Body)
      end function
    
    end class 'WithStatement


    '    export class TryCatch extends ASTBase
    ' constructor
    Class TryCatch
    Inherits ASTBase
        Public Property body as Object
          Public Property exceptionBlock as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'try'
        Me.req("try")
        '.lock()
        Me.lock()
        '.body = .req(Body)
        Me.body = Me.req(Body)

        '.exceptionBlock = .req(ExceptionBlock)
        Me.exceptionBlock = Me.req(ExceptionBlock)

        'if .exceptionBlock.indent isnt .indent
        if Me.exceptionBlock.indent <> Me.indent Then
        
            '.sayErr "try: misaligned try-catch indent"
            Me.sayErr("try: misaligned try-catch indent")
            '.exceptionBlock.sayErr "catch: misaligned try-catch indent"
            Me.exceptionBlock.sayErr("catch: misaligned try-catch indent")
        
        End if
        
      end function
    
    end class 'TryCatch

    '    export class ExceptionBlock extends ASTBase
    ' constructor
    Class ExceptionBlock
    Inherits ASTBase
        Public Property catchVar as String' mainType: String  
      
          Public Property body as Object
          Public Property finallyBody as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.keyword = .req('catch','exception','Exception')
        Me.keyword = Me.req("catch", "exception", "Exception")
        '.keyword = .keyword.toLowerCase()
        Me.keyword = Me.keyword.toLowerCase()
        '.lock()
        Me.lock()

'in order to correctly count frames to unwind on "return" from inside a try-catch
'catch"'s parent MUST BE ONLY "try"

        'if .keyword is 'catch' and .parent.constructor isnt TryCatch
        if Me.keyword = "catch" AndAlso Me.parent.constructor <> TryCatch Then
        
            '.throwError "internal error, expected 'try' as 'catch' previous block"
            Me.throwError("internal error, expected 'try' as 'catch' previous block")
        
        End if

'get catch variable - Note: catch variables in js are block-scoped

        '.catchVar = .req('IDENTIFIER')
        Me.catchVar = Me.req("IDENTIFIER")

'get body

        '.body = .req(Body)
        Me.body = Me.req(Body)

'get optional "finally" block

        'if .opt('finally'), .finallyBody = .req(Body)
        if Me.opt("finally") Then Me.finallyBody = Me.req(Body)

'validate grammar: try=>catch / function=>exception

        'if .keyword is 'exception'
        if Me.keyword = "exception" Then
        

            'if .parent.constructor isnt Statement
            if Me.parent.constructor <> Statement OrElse Not (TypeOf Me.parent.parent is Body) OrElse Not (TypeOf Me.parent.parent.parent is FunctionDeclaration) Then
            
                  '.sayErr '"Exception" block should be the part of function/method/constructor body - use "catch" to match a "try" block'
                  Me.sayErr(""Exception" block should be the part of function/method/constructor body - use "catch" to match a "try" block")
            
            End if

'here, it is a "exception" block in a FunctionDeclaration.
'Mark the function as having an ExceptionBlock in order to
'insert "try{" at function start and also handle C-exceptions unwinding

            'var theFunctionDeclaration = .parent.parent.parent
            Dim theFunctionDeclaration = Me.parent.parent.parent
            'theFunctionDeclaration.hasExceptionBlock = true
            theFunctionDeclaration.hasExceptionBlock = true
        
        End if
        
      end function
    
    end class 'ExceptionBlock


    '    export class ThrowStatement extends ASTBase
    ' constructor
    Class ThrowStatement
    Inherits ASTBase
        Public Property specifier as Object
          Public Property expr as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.specifier = .req('throw', 'raise', 'fail')
        Me.specifier = Me.req("throw", "raise", "fail")

'At this point we lock because it is definitely a `throw` statement

        '.lock()
        Me.lock()
        'if .specifier is 'fail', .req 'with'
        if Me.specifier = "fail" Then Me.req("with")
        '.expr = .req(Expression) #trow expression
        Me.expr = Me.req(Expression)
      end function
    
    end class 'ThrowStatement


    '    export class ReturnStatement extends ASTBase
    ' constructor
    Class ReturnStatement
    Inherits ASTBase
        Public Property expr as Expression' mainType: Expression  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'return'
        Me.req("return")
        '.lock()
        Me.lock()
        '.expr = .opt(Expression)
        Me.expr = Me.opt(Expression)
      end function
    
    end class 'ReturnStatement


    '    export class IfStatement extends ASTBase
    ' constructor
    Class IfStatement
    Inherits ASTBase
        Public Property conditional as Expression' mainType: Expression  
      
          Public Property body as Object
          Public Property elseStatement as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'if','when'
        Me.req("if", "when")
        '.lock()
        Me.lock()
        '.conditional = .req(Expression)
        Me.conditional = Me.req(Expression)

'after `,` or `then`, a statement on the same line is required
'if we're processing all single-line if's, ',|then' are *required*

'choose same body class as parent:
'either SingleLineBody or Body (multiline indented)

        'if .opt(',','then')
        if Me.opt(",", "then") Then
        
            '.body = .req(SingleLineBody)
            Me.body = Me.req(SingleLineBody)
        
        'if .opt(',','then')
        
        else
        
            '.body = .req(Body)
            Me.body = Me.req(Body)
        
        End if
        'end if

'control: "if"-"else" are related by having the same indent

        'if .lexer.token.value is 'else'
        

'control: "if"-"else" are related by having the same indent

        'if .lexer.token.value is 'else'
        if Me.lexer.token.value = "else" Then
        

            'if .lexer.index isnt 0
            if Me.lexer.index <> 0 Then
            
                '.throwError 'expected "else" to start on a new line'
                Me.throwError("expected "else" to start on a new line")
            
            End if

            'if .lexer.indent < .indent
            if Me.lexer.indent < Me.indent Then
            
                '#token is 'else' **BUT IS LESS-INDENTED**. It is not the "else" to this "if"
                'return
                return
            
            End if

            'if .lexer.indent > .indent
            if Me.lexer.indent > Me.indent Then
            
                '.throwError "'else' statement is over-indented"
                Me.throwError("'else' statement is over-indented")
            
            End if
            
        
        End if

        'end if

'Now get optional `[ElseIfStatement|ElseStatement]`

        '.elseStatement = .opt(ElseIfStatement, ElseStatement)
        

'Now get optional `[ElseIfStatement|ElseStatement]`

        '.elseStatement = .opt(ElseIfStatement, ElseStatement)
        Me.elseStatement = Me.opt(ElseIfStatement, ElseStatement)
      end function
    
    end class 'IfStatement


    '    export class ElseIfStatement extends ASTBase
    ' constructor
    Class ElseIfStatement
    Inherits ASTBase
        Public Property nextIf as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'else'
        Me.req("else")
        '.req 'if'
        Me.req("if")
        '.lock()
        Me.lock()

'return the consumed 'if', to parse as a normal `IfStatement`

        '.lexer.returnToken()
        Me.lexer.returnToken()
        '.nextIf = .req(IfStatement)
        Me.nextIf = Me.req(IfStatement)
      end function
    
    end class 'ElseIfStatement


    '    export class ElseStatement extends ASTBase
    ' constructor
    Class ElseStatement
    Inherits ASTBase
        Public Property body as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'else'
        Me.req("else")
        '.lock()
        Me.lock()
        '.body = .req(Body)
        Me.body = Me.req(Body)
      end function
    
    end class 'ElseStatement


'Loops
'=====

'LiteScript provides the standard js and C `while` loop, a `until` loop
'and a `do... loop while|until`


'DoLoop
'------

'`DoLoop: do [pre-WhileUntilExpression] [":"] Body loop`
'`DoLoop: do [":"] Body loop [post-WhileUntilExpression]`

'do-loop can have a optional pre-condition or a optional post-condition

'##### Case 1) do-loop without any condition

'a do-loop without any condition is an *infinite loop* (usually with a `break` statement inside)

'Example:
'```
'var x=1
'do:
  'x++
  'print x
  'if x is 10, break
'loop
'```

'##### Case 2) do-loop with pre-condition

'A do-loop with pre-condition, is the same as a while|until loop

'Example:
'```
'var x=1
'do while x<10
  'x++
  'print x
'loop
'```

'##### Case 3) do-loop with post-condition

'A do-loop with post-condition, execute the block, at least once, and after each iteration,
'checks the post-condition, and loops `while` the expression is true
'*or* `until` the expression is true

'Example:
'```
'var x=1
'do
  'x++
  'print x
'loop while x < 10
'```

'#### Implementation

    'public class DoLoop extends ASTBase
    ' constructor
    Class DoLoop
    Inherits ASTBase
        Public Property preWhileUntilExpression as Object
          Public Property body as Object
          Public Property postWhileUntilExpression as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'do'
        Me.req("do")
        'if .opt('nothing')
        if Me.opt("nothing") Then
        
          '.throwParseFailed('is do nothing')
          Me.throwParseFailed("is do nothing")
        
        End if
        '.opt ":"
        Me.opt(":")
        '.lock()
        Me.lock()

'Get optional pre-condition

        '.preWhileUntilExpression = .opt(WhileUntilExpression)
        Me.preWhileUntilExpression = Me.opt(WhileUntilExpression)
        '.body = .opt(Body)
        Me.body = Me.opt(Body)
        '.req "loop"
        Me.req("loop")

'Get optional post-condition

        '.postWhileUntilExpression = .opt(WhileUntilExpression)
        Me.postWhileUntilExpression = Me.opt(WhileUntilExpression)
        'if .preWhileUntilExpression and .postWhileUntilExpression
        if Me.preWhileUntilExpression AndAlso Me.postWhileUntilExpression Then
        
          '.sayErr "Loop: cannot have a pre-condition a and post-condition at the same time"
          Me.sayErr("Loop: cannot have a pre-condition a and post-condition at the same time")
        
        End if
        
      end function
    
    end class 'DoLoop


    '    export class WhileUntilLoop extends DoLoop
    ' constructor
    Class WhileUntilLoop
    Inherits DoLoop
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.preWhileUntilExpression = .req(WhileUntilExpression)
        Me.preWhileUntilExpression = Me.req(WhileUntilExpression)
        '.lock()
        Me.lock()
        '.body = .opt(Body)
        Me.body = Me.opt(Body)
      end function
    
    end class 'WhileUntilLoop


    '    export helper class WhileUntilExpression extends ASTBase
    ' constructor
    Class WhileUntilExpression
    Inherits ASTBase
        Public Property expr as Expression' mainType: Expression  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.name = .req('while','until')
        Me.name = Me.req("while", "until")
        '.lock()
        Me.lock()
        '.expr = .req(Expression)
        Me.expr = Me.req(Expression)
      end function
    
    end class 'WhileUntilExpression


    '    export class LoopControlStatement extends ASTBase
    ' constructor
    Class LoopControlStatement
    Inherits ASTBase
        Public Property control as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.control = .req('break','continue')
        Me.control = Me.req("break", "continue")
        '.opt 'loop'
        Me.opt("loop")
      end function
    
    end class 'LoopControlStatement

    '    export class DoNothingStatement extends ASTBase
    ' constructor
    Class DoNothingStatement
    Inherits ASTBase
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'do'
        Me.req("do")
        '.req 'nothing'
        Me.req("nothing")
      end function
    
    end class 'DoNothingStatement


'## For Statement

    '    export class ForStatement extends ASTBase
    ' constructor
    Class ForStatement
    Inherits ASTBase
        Public Property variant as ASTBase' mainType: ASTBase  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        'declare valid .createScope
        

'We start with commonn `for` keyword

        '.req 'for'
        Me.req("for")
        '.lock()
        Me.lock()

'we now require one of the variants

        '.variant = .req(ForEachProperty,ForEachInArray,ForIndexNumeric)
        Me.variant = Me.req(ForEachProperty, ForEachInArray, ForIndexNumeric)
      end function
    
    end class 'ForStatement

'##Variant 1) **for each [own] property**
'###Loop over **object property names**

'Grammar:
'`ForEachProperty: for each [own] property name-VariableDecl ["," value-VariableDecl] in object-VariableRef [where Expression]`

'where `name-VariableDecl` is a variable declared on the spot to store each property name,
'and `object-VariableRef` is the object having the properties

    '    export class ForEachProperty extends ASTBase
    ' constructor
    Class ForEachProperty
    Inherits ASTBase
        Public Property keyIndexVar as VariableDecl' mainType: VariableDecl  
      
          Public Property valueVar as VariableDecl' mainType: VariableDecl  
      
          Public Property iterable as Expression' mainType: Expression  
      
          Public Property where as ForWhereFilter' mainType: ForWhereFilter  
      
          Public Property body as Object
          Public Property ownKey as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req('each')
        Me.req("each")

'optional "own"

        'if .opt("own") into .ownKey
        if Assign(Me.ownKey,Me.opt("own")) Then
        
          '.lock()
          Me.lock()
        
        End if

'next we require: 'property', and lock.

        '.req('property')
        Me.req("property")
        '.lock()
        Me.lock()

'Get main variable name (to store property value)

        '.valueVar = .req(VariableDecl)
        Me.valueVar = Me.req(VariableDecl)

'if comma present, it was propName-index (to store property names)

        'if .opt(",")
        if Me.opt(",") Then
        
          '.keyIndexVar = .valueVar
          Me.keyIndexVar = Me.valueVar
          '.valueVar = .req(VariableDecl)
          Me.valueVar = Me.req(VariableDecl)
        
        End if

'Then we require `in`, and the iterable-Expression (a object)

        '.req 'in'
        Me.req("in")
        '.iterable = .req(Expression)
        Me.iterable = Me.req(Expression)

'optional where expression (filter)

        '.where = .opt(ForWhereFilter)
        Me.where = Me.opt(ForWhereFilter)

'Now, get the loop body

        '.body = .req(Body)
        Me.body = Me.req(Body)
      end function
    
    end class 'ForEachProperty


'##Variant 2) **for each in**
'### loop over **Arrays**

'Grammar:
'`ForEachInArray: for each [index-VariableDecl,]item-VariableDecl in array-VariableRef [where Expression]`

'where:
'* `index-VariableDecl` is a variable declared on the spot to store each item index (from 0 to array.length)
'* `item-VariableDecl` is a variable declared on the spot to store each array item (array[index])
'and `array-VariableRef` is the array to iterate over

    '    export class ForEachInArray extends ASTBase
    ' constructor
    Class ForEachInArray
    Inherits ASTBase
        Public Property intIndexVar as VariableDecl' mainType: VariableDecl  
      
          Public Property keyIndexVar as VariableDecl' mainType: VariableDecl  
      
          Public Property valueVar as VariableDecl' mainType: VariableDecl  
      
          Public Property iterable as Expression' mainType: Expression  
      
          Public Property where as ForWhereFilter' mainType: ForWhereFilter  
      
          Public Property body as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

'first, require 'each'

        '.req 'each'
        Me.req("each")

'Get value variable name.
'Keep it simple: index and value are always variables declared on the spot

        '.valueVar = .req(VariableDecl)
        Me.valueVar = Me.req(VariableDecl)

'a comma means: previous var was 'nameIndex', so register previous as index and get value var

        'if .opt(',')
        if Me.opt(",") Then
        
          '.keyIndexVar = .valueVar
          Me.keyIndexVar = Me.valueVar
          '.valueVar = .req(VariableDecl)
          Me.valueVar = Me.req(VariableDecl)
        
        End if

'another comma means: full 3 vars: for each intIndex,nameIndex,value in iterable.
'Previous two where intIndex & nameIndex

        'if .opt(',')
        if Me.opt(",") Then
        
          '.intIndexVar = .keyIndexVar
          Me.intIndexVar = Me.keyIndexVar
          '.keyIndexVar = .valueVar
          Me.keyIndexVar = Me.valueVar
          '.valueVar = .req(VariableDecl)
          Me.valueVar = Me.req(VariableDecl)
        
        End if

'we now *require* `in` and the iterable: Object|Map|Array... any class having a iterableNext(iter) method

        '.req 'in'
        Me.req("in")
        '.lock()
        Me.lock()
        '.isMap = .opt('map')
        Me.isMap = Me.opt("map")
        '.iterable = .req(Expression)
        Me.iterable = Me.req(Expression)

'optional where expression

        '.where = .opt(ForWhereFilter)
        Me.where = Me.opt(ForWhereFilter)

'and then, loop body

        '.body = .req(Body)
        Me.body = Me.req(Body)
      end function
    
    end class 'ForEachInArray


'##Variant 3) **for index=...**
'### to do **numeric loops**

'This `for` variant is just a verbose expressions of the standard C (and js) `for(;;)` loop

'Grammar:
'`ForIndexNumeric: for index-VariableDecl [","] (while|until|to|down to) end-Expression ["," increment-SingleLineBody]`

'where `index-VariableDecl` is a numeric variable declared on the spot to store loop index,
'`start-Expression` is the start value for the index (ussually 0)
'`end-Expression` is:
'- the end value (`to`)
'- the condition to keep looping (`while`)
'- the condition to end looping (`until`)
'<br>and `increment-SingleLineBody` is the statement(s) used to advance the loop index.
'If omitted the default is `index++`

    '    export class ForIndexNumeric extends ASTBase
    ' constructor
    Class ForIndexNumeric
    Inherits ASTBase
        Public Property keyIndexVar as VariableDecl' mainType: VariableDecl  
      
          Public Property conditionPrefix as Object
          Public Property endExpression as Object
          Public Property increment as SingleLineBody' mainType: SingleLineBody  
      
          Public Property body as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.keyIndexVar = .req(VariableDecl)
        Me.keyIndexVar = Me.req(VariableDecl)
        '.lock()
        Me.lock()

'next comma is  optional, then
'get 'while|until|to' and condition

        '.opt ','
        Me.opt(",")
        '.conditionPrefix = .req('while','until','to','down')
        Me.conditionPrefix = Me.req("while", "until", "to", "down")
        'if .conditionPrefix is 'down', .req 'to'
        if Me.conditionPrefix = "down" Then Me.req("to")
        '.endExpression = .req(Expression)
        Me.endExpression = Me.req(Expression)

'another optional comma, and increment-Statement(s)

        'if .opt(',')
        if Me.opt(",") Then
        
          '.increment = .req(SingleLineBody)
          Me.increment = Me.req(SingleLineBody)
          '.lexer.returnToken //return closing NEWLINE, for the indented body
          Me.lexer.returnToken()
        
        End if

'Now, get the loop body

        '.body = .req(Body)
        Me.body = Me.req(Body)
      end function
    
    end class 'ForIndexNumeric



    '    public helper class ForWhereFilter extends ASTBase
    ' constructor
    Class ForWhereFilter
    Inherits ASTBase
        Public Property filterExpression as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        'var optNewLine = .opt('NEWLINE')
        Dim optNewLine = Me.opt("NEWLINE")

        'if .opt('where')
        if Me.opt("where") Then
        
          '.lock()
          Me.lock()
          '.filterExpression = .req(Expression)
          Me.filterExpression = Me.req(Expression)
        
        'if .opt('where')
        
        else
        
          'if optNewLine, .lexer.returnToken # return NEWLINE
          if optNewLine Then Me.lexer.returnToken()
          '.throwParseFailed "expected '[NEWLINE] where'"
          Me.throwParseFailed("expected '[NEWLINE] where'")
        
        End if
        
      end function
    
    end class 'ForWhereFilter

'--------------------------------

    '    public class DeleteStatement extends ASTBase
    ' constructor
    Class DeleteStatement
    Inherits ASTBase
        Public Property varRef as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req('delete')
        Me.req("delete")
        '.lock()
        Me.lock()
        '.varRef = .req(VariableRef)
        Me.varRef = Me.req(VariableRef)
      end function
    
    end class 'DeleteStatement


    '    export class AssignmentStatement extends ASTBase
    ' constructor
    Class AssignmentStatement
    Inherits ASTBase
        Public Property lvalue as VariableRef' mainType: VariableRef  
      
          Public Property rvalue as Expression' mainType: Expression  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        'declare valid .parent.preParsedVarRef
        

        'if .parent instanceof Statement and .parent.preParsedVarRef
        if TypeOf Me.parent is Statement AndAlso Me.parent.preParsedVarRef Then
        
          '.lvalue  = .parent.preParsedVarRef # get already parsed VariableRef
          Me.lvalue = Me.parent.preParsedVarRef
        
        'if .parent instanceof Statement and .parent.preParsedVarRef
        
        else
        
          '.lvalue  = .req(VariableRef)
          Me.lvalue = Me.req(VariableRef)
        
        End if

'require an assignment symbol: ("="|"+="|"-="|"*="|"/=")

        '.name = .req('ASSIGN')
        Me.name = Me.req("ASSIGN")
        '.lock()
        Me.lock()

        'if .lexer.token.value is 'map' #dangling assignment - Literal map
        if Me.lexer.token.value = "map" Then
        
          '.req 'map'
          Me.req("map")
          '.rvalue  = .req(FreeObjectLiteral) #assume Object Expression in freeForm mode
          Me.rvalue = Me.req(FreeObjectLiteral)
          '.rvalue.type = 'Map'
          Me.rvalue.type = "Map"
          '.rvalue.isMap = true
          Me.rvalue.isMap = true
        
        'if .lexer.token.value is 'map' #dangling assignment - Literal map
        
        elseif Me.lexer.token.type = "NEWLINE" Then
        
          '.rvalue  = .req(FreeObjectLiteral) #assume Object Expression in freeForm mode
          Me.rvalue = Me.req(FreeObjectLiteral)
        
        'else if .lexer.token.type is 'NEWLINE' #dangling assignment
        
        else
        
          '.rvalue  = .req(Expression)
          Me.rvalue = Me.req(Expression)
        
        End if
        End if
        
      end function
    
    end class 'AssignmentStatement


'-----------------------

    '    export class VariableRef extends ASTBase
    ' constructor
    Class VariableRef
    Inherits ASTBase
        Public Property preIncDec as Object
          Public Property postIncDec as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.preIncDec = .opt('--','++')
        Me.preIncDec = Me.opt("--", "++")
        '.executes = false
        Me.executes = false

'assume 'this.x' on '.x', or if we're in a WithStatement, the 'with' .name

'get var name

        'if .opt('.','SPACE_DOT') # note: DOT has SPACES in front when .property used as parameter
        if Me.opt(".", "SPACE_DOT") Then
        

            '#'.name' -> 'x.name'
            '.lock()
            Me.lock()

            'if .getParent(WithStatement) into var withStatement
            Dim withStatement as Object
            if Assign(withStatement,Me.getParent(WithStatement)) Then
            
                '.name = withStatement.name
                Me.name = withStatement.name
            
            'if .getParent(WithStatement) into var withStatement
            
            else
            
                '.name = 'this' #default replacement for '.x'
                Me.name = "this"
            
            End if

            'var member: string
            Dim member = Nothing
            '#we must allow 'not' and 'has' as method names, (jQuery uses "not", Map uses "has").
            '#They're classsified as "Opers", but they're valid identifiers in this context
            'if .lexer.token.value in ['not','has']
            if new ArrayList From {"not", "has"}
            .Contains(Me.lexer.token.value) Then
            
                'member = .lexer.nextToken() //get not|has as identifier
                member = Me.lexer.nextToken()
            
            'if .lexer.token.value in ['not','has']
            
            else
            
                'member = .req('IDENTIFIER')
                member = Me.req("IDENTIFIER")
            
            End if

            '.addAccessor new PropertyAccess(this,member)
            Me.addAccessor(new PropertyAccess(Me, member))
        
        'if .opt('.','SPACE_DOT') # note: DOT has SPACES in front when .property used as parameter
        
        else
        

            '.name = .req('IDENTIFIER')
            Me.name = Me.req("IDENTIFIER")
        
        End if

        '.lock()
        Me.lock()

'Now we check for accessors:
'<br>`.`->**PropertyAccess**
'<br>`[...]`->**IndexAccess**
'<br>`(...)`->**FunctionAccess**

'Note: **.paserAccessors()** will:
'- set .hasSideEffects=true if a function accessor is parsed
'- set .executes=true if the last accessor is a function accessor

        '.parseAccessors
        Me.parseAccessors()

'Replace lexical `super` by `#{SuperClass name}.prototype`

        'if .name is 'super'
        if Me.name = "super" Then
        

            'var classDecl = .getParent(ClassDeclaration)
            Dim classDecl = Me.getParent(ClassDeclaration)
            'if no classDecl
            if NotclassDecl Then
            
              '.throwError "use of 'super' outside a class method"
              Me.throwError("use of 'super' outside a class method")
            
            End if

            'if classDecl.varRefSuper
            if classDecl.varRefSuper Then
            
                '#replace name='super' by name = #{SuperClass name}
                '.name = classDecl.varRefSuper.toString()
                Me.name = classDecl.varRefSuper.toString()
            
            'if classDecl.varRefSuper
            
            else
            
                '.name ='Object' # no superclass means 'Object' is super class
                Me.name = "Object"
            
            End if
            
        
        End if

        'end if super

'Hack: after 'into var', allow :type

        'if .getParent(Statement).intoVars and .opt(":")
        

'Hack: after 'into var', allow :type

        'if .getParent(Statement).intoVars and .opt(":")
        if Me.getParent(Statement).intoVars AndAlso Me.opt(":") Then
        
            '.type = .req(TypeDeclaration)
            Me.type = Me.req(TypeDeclaration)
        
        End if

'check for post-fix increment/decrement

        '.postIncDec = .opt('--','++')
        Me.postIncDec = Me.opt("--", "++")

'If this variable ref has ++ or --, IT IS CONSIDERED a "call to execution" in itself,
'a "imperative statement", because it has side effects.
'(`i++` has a "imperative" part, It means: "give me the value of i, and then increment it!")

        'if .preIncDec or .postIncDec
        if Me.preIncDec OrElse Me.postIncDec Then
        
          '.executes = true
          Me.executes = true
          '.hasSideEffects = true
          Me.hasSideEffects = true
        
        End if
        
      end function
      ' ---------------------------
      Public Function toString ()
'This method is only valid to be used in error reporting.
'function accessors will be output as "(...)", and index accessors as [...]

        'var result = "#{.preIncDec or ''}#{.name}"
        Dim result = "" + (Me.preIncDec OrElse "") + Me.name
        'if .accessors
        if Me.accessors Then
        
          'for each ac in .accessors
          For Each ac in Me.accessors
          
            'result = "#{result}#{ac.toString()}"
            result = "" + result + (ac.toString())
          Next'  each in Me.accessors
          
        
        End if
        'return "#{result}#{.postIncDec or ''}"
        return "" + result + (Me.postIncDec OrElse "")
      end function
    
    end class 'VariableRef

'-----------------------

'## Accessors

'`Accessors: (PropertyAccess|FunctionAccess|IndexAccess)`

'Accessors:
  '`PropertyAccess: '.' IDENTIFIER`
  '`IndexAccess:    '[' Expression ']'`
  '`FunctionAccess: '(' [Expression,]* ')'`

'Accessors can appear after a VariableRef (most common case)
'but also after a String constant, a Regex Constant,
'a ObjectLiteral and a ArrayLiteral

'Examples:
'- `myObj.item.fn(call)`  <-- 3 accesors, two PropertyAccess and a FunctionAccess
'- `myObj[5](param).part`  <-- 3 accesors, IndexAccess, FunctionAccess and PropertyAccess
'- `[1,2,3,4].indexOf(3)` <-- 2 accesors, PropertyAccess and FunctionAccess


'#####Actions:

'`.` -> PropertyAccess: Search the property in the object and in his pototype chain.
                      'It resolves to the property value

'`[...]` -> IndexAccess: Same as PropertyAccess

'`(...)` -> FunctionAccess: The object is assumed to be a function, and the code executed.
                      'It resolves to the function return value.

'## Implementation
'We provide a class Accessor to be super class for the three accessors types.

    '    export class Accessor extends ASTBase
    ' constructor
    Class Accessor
    Inherits ASTBase
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        'fail with 'abstract'
        Throw New System.Exception("abstract")
      end function
      ' ---------------------------
      Public Function toString ()
        'fail with 'abstract'
        Throw New System.Exception("abstract")
      end function
    
    end class 'Accessor


    '    export class PropertyAccess extends Accessor
    ' constructor
    Class PropertyAccess
    Inherits Accessor
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req('.')
        Me.req(".")
        '.lock()
        Me.lock()
        'if .lexer.token.value is '{' // ObjectLiteral, short-form for  `.initFromObject({a:1,b:2})`
        if Me.lexer.token.value = "{" Then
        
            '.name='newFromObject' // fixed property access "initFromObject" (call-to)
            Me.name = "newFromObject"
        
        'if .lexer.token.value is '{' // ObjectLiteral, short-form for  `.initFromObject({a:1,b:2})`
        
        elseif new ArrayList From {"not", "has"}
        .Contains(Me.lexer.token.value) Then
        
            '.name = .lexer.token.value //get "not"|"has" as identifier
            Me.name = Me.lexer.token.value
            '.lexer.nextToken() //advance
            Me.lexer.nextToken()
        
        'else if .lexer.token.value in ['not','has']
        
        else
        
            '.name = .req('IDENTIFIER')
            Me.name = Me.req("IDENTIFIER")
        
        End if
        End if
        
      end function
      ' ---------------------------
      Public Function toString ()
        'return '.#{.name}'
        return "." + Me.name
      end function
    
    end class 'PropertyAccess


    '    export class IndexAccess extends Accessor
    ' constructor
    Class IndexAccess
    Inherits Accessor
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req "["
        Me.req("[")
        '.lock()
        Me.lock()
        '.name = .req( Expression )
        Me.name = Me.req(Expression)
        '.req "]" #closer ]
        Me.req("]")
      end function
      ' ---------------------------
      Public Function toString ()
        'return '[...]'
        return "[...]"
      end function
    
    end class 'IndexAccess


    '    export class FunctionArgument extends ASTBase
    ' constructor
    Class FunctionArgument
    Inherits ASTBase
        Public Property expression as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.lock()
        Me.lock()

        'if .opt('IDENTIFIER') into .name
        if Assign(Me.name,Me.opt("IDENTIFIER")) Then
        
            'if .lexer.token.value is '='
            if Me.lexer.token.value = "=" Then
            
                '.req '='
                Me.req("=")
            
            'if .lexer.token.value is '='
            
            else
            
                '.lexer.returnToken
                Me.lexer.returnToken()
                '.name = undefined
                Me.name = undefined
            
            End if
            
        
        End if

        '.expression =.req(Expression)
        Me.expression = Me.req(Expression)
      end function
    
    end class 'FunctionArgument


    '    export class FunctionAccess extends Accessor
    ' constructor
    Class FunctionAccess
    Inherits Accessor
        Public Property args as Array' mainType: Array  ' itemType: FunctionArgument
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req "("
        Me.req("(")
        '.lock()
        Me.lock()
        '.args = .optSeparatedList( FunctionArgument, ",", ")" ) #comma-separated list of FunctionArgument, closed by ")"
        Me.args = Me.optSeparatedList(FunctionArgument, ",", ")")
      end function
      ' ---------------------------
      Public Function toString ()
        'return '(...)'
        return "(...)"
      end function
    
    end class 'FunctionAccess

'## Functions appended to ASTBase, to help parse accessors on any node

    '    append to class ASTBase
    Partial Class ASTBase
    
      'properties
        'accessors: Accessor array
        'executes, hasSideEffects

      '      helper method parseAccessors
          Public Property accessors as Array' mainType: Array  ' itemType: Accessor
      
          Public Property executes as Object
          Public Property hasSideEffects as Object

      '      helper method parseAccessors
      ' ---------------------------
      Public Function parseAccessors ()

'We store the accessors in the property: .accessors
'if the accessors array exists, it will have **at least one item**.

'Loop parsing accessors

          'var ac:Accessor
          Dim ac = Nothing

          'do
          Do whiletrue
          

              'case .lexer.token.value
              select Me.lexer.token.value
              case "."
              

                    'ac = new PropertyAccess(this)
                    ac = new PropertyAccess(Me)
                    'ac.parse
                    ac.parse()
              
              
              case "("
              

                    'ac = new FunctionAccess(this)
                    ac = new FunctionAccess(Me)
                    'ac.parse
                    ac.parse()
              
              
              case "["
              

                    'ac = new IndexAccess(this)
                    ac = new IndexAccess(Me)
                    'ac.parse
                    ac.parse()
              
              
              
              case else
              
                    'break //no more accessors
                    break
              

              'end case

              '//add parsed accessor
              '.addAccessor ac
              

              '//add parsed accessor
              '.addAccessor ac
              Me.addAccessor(ac)
          
          Loop

          'return
          return
      end function

      '      helper method addAccessor(item)
      ' ---------------------------
      Public Function addAccessor (item)

            '#create accessors list, if there was none
            'if no .accessors, .accessors = []
            if NotMe.accessors Then Me.accessors = new ArrayList

            '#polymorphic params: string defaults to PropertyAccess
            'if type of item is 'string', item = new PropertyAccess(this, item)
            if TypeOf item = "string" Then item = new PropertyAccess(Me, item)

            '.accessors.push item
            Me.accessors.push(item)

'if the very last accesor is "(", it means the entire expression is a function call,
'it's a call to "execute code", so it's a imperative statement on it's own.
'if any accessor is a function call, this statement is assumed to have side-effects

            '.executes = item instance of FunctionAccess
            Me.executes = TypeOf item is FunctionAccess
            'if .executes, .hasSideEffects = true
            if Me.executes Then Me.hasSideEffects = true
      end function
      
    
    End Class 'partial


'## Operand

'```
'Operand: (
  '(NumberLiteral|StringLiteral|RegExpLiteral|ArrayLiteral|ObjectLiteral
                    '|ParenExpression|FunctionDeclaration)[Accessors])
  '|VariableRef)
'```

'Examples:
'<br> 4 + 3 -> `Operand Oper Operand`
'<br> -4    -> `UnaryOper Operand`

'A `Operand` is the data on which the operator operates.
'It's the left and right part of a binary operator.
'It's the data affected (righ) by a UnaryOper.

'To make parsing faster, associate a token type/value,
'with exact AST class to call parse() on.

    'var OPERAND_DIRECT_TYPE = map

          ''STRING': StringLiteral
          ''NUMBER': NumberLiteral
          ''REGEX': RegExpLiteral
          ''SPACE_BRACKET':ArrayLiteral # one or more spaces + "["


    'var OPERAND_DIRECT_TOKEN = map
    Dim OPERAND_DIRECT_TYPE = new Dictionary(Of String,Object) from {
        {"STRING",StringLiteral}
        , {"NUMBER",NumberLiteral}
        , {"REGEX",RegExpLiteral}
        , {"SPACE_BRACKET",ArrayLiteral}
          }


    'var OPERAND_DIRECT_TOKEN = map

          ''(':ParenExpression
          ''[':ArrayLiteral
          ''{':ObjectLiteral
          ''function': FunctionDeclaration
          ''->': FunctionDeclaration
          ''yield': YieldExpression


    '    public class Operand extends ASTBase
    Dim OPERAND_DIRECT_TOKEN = new Dictionary(Of String,Object) from {
        {"(",ParenExpression}
        , {"[",ArrayLiteral}
        , {"{",ObjectLiteral}
        , {"function",FunctionDeclaration}
        , {"->",FunctionDeclaration}
        , {"yield",YieldExpression}
          }


    '    public class Operand extends ASTBase
    ' constructor
    Class Operand
    Inherits ASTBase
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.name = .parseDirect(.lexer.token.type, OPERAND_DIRECT_TYPE)
          'or .parseDirect(.lexer.token.value, OPERAND_DIRECT_TOKEN)
        Me.name = Me.parseDirect(Me.lexer.token.type, OPERAND_DIRECT_TYPE) OrElse Me.parseDirect(Me.lexer.token.value, OPERAND_DIRECT_TOKEN)

'if it was a Literal, ParenExpression or FunctionDeclaration
'besides base value, this operands can have accessors. For example: `"string".length` , `myObj.fn(10)`
'NOTE: ONLY IF ON THE SAME LINE. After a callback function declaration, there can be a '.' starting
'another statement and w/o "on the same line" restriction it will consider such dot as
'function object property access.

        'if .name
        if Me.name Then
        
            'if .lexer.sourceLineNum is .sourceLineNum
            if Me.lexer.sourceLineNum = Me.sourceLineNum Then
            
                '.parseAccessors
                Me.parseAccessors()
            
            End if
            
        
        'if .name
        
        else
        
            '.name = .req(VariableRef)
            Me.name = Me.req(VariableRef)
        
        End if

        'end if

    'end Operand
        
      end function
    
    end class 'Operand


'## Oper

'```
'Oper: ('~'|'&'|'^'|'|'|'>>'|'<<'
        '|'*'|'/'|'+'|'-'|mod
        '|instance of|instanceof
        '|'>'|'<'|'>='|'<='
        '|is|'==='|isnt|is not|'!=='
        '|and|but|or
        '|[not] in
        '|(has|hasnt) property
        '|? true-Expression : false-Expression)`
'```

'An Oper sits between two Operands ("Oper" is a "Binary Operator",
'different from *UnaryOperators* which optionally precede a Operand)

'If an Oper is found after an Operand, a second Operand is expected.

'Operators can include:
'* arithmetic operations "*"|"/"|"+"|"-"
'* boolean operations "and"|"or"
'* `in` collection check.  (js: `indexOx()>=0`)
'* instance class checks   (js: instanceof)
'* short-if ternary expressions ? :
'* bit operations (|&)
'* `has property` object property check (js: 'propName in object')

    '    public class Oper extends ASTBase
    ' constructor
    Class Oper
    Inherits ASTBase
        Public Property negated as Object
          Public Property left as Operand' mainType: Operand  
      
          Public Property right as Operand' mainType: Operand  
      
          Public Property pushed as Object
          Public Property precedence as Object
          Public Property intoVar as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        'declare valid .getPrecedence
        
        'declare valid .parent.ternaryCount
        
        'if .parent.ternaryCount and .opt('else')
        if Me.parent.ternaryCount AndAlso Me.opt("else") Then
        
            '.name=':' # if there's a open ternaryCount, 'else' is converted to ":"
            Me.name = ":"
        
        'if .parent.ternaryCount and .opt('else')
        
        else
        
            '.name = .req('OPER')
            Me.name = Me.req("OPER")
        
        End if

        '.lock()
        Me.lock()

'A) validate double-word opers

'A.1) validate `instance of`

        'if .name is 'instance'
        if Me.name = "instance" Then
        
            '.req('of')
            Me.req("of")
            '.name = "instance of"
            Me.name = "instance of"
        
        'if .name is 'instance'
        
        elseif Me.name = "has" Then
        
            '.negated = .opt('not')? true:false # set the 'negated' flag
            Me.negated = Me.opt("not") ? true : false
            '.req('property')
            Me.req("property")
            '.name = "has property"
            Me.name = "has property"
        
        'else if .name is 'has'
        
        elseif Me.name = "hasnt" Then
        
            '.req('property')
            Me.req("property")
            '.negated = true # set the 'negated' flag
            Me.negated = true
            '.name = "has property"
            Me.name = "has property"
        
        'else if .name is 'hasnt'
        
        elseif Me.name = "not" Then
        
            '.negated = true # set the 'negated' flag
            Me.negated = true
            '.name = .req('in','like') # require 'not in'|'not like'
            Me.name = Me.req("in", "like")
        
        End if
        End if
        End if
        End if

'A.4) handle 'into [var] x', assignment-Expression

        'if .name is 'into' and .opt('var')
        if Me.name = "into" AndAlso Me.opt("var") Then
        
            '.intoVar = '*r' //.right operand is "into" var
            Me.intoVar = "*r"
            '.getParent(Statement).intoVars = true #mark owner statement
            Me.getParent(Statement).intoVars = true
        
        'if .name is 'into' and .opt('var')
        
        elseif Me.name = "or" Then
        
            'if .lexer.options.target is 'c'
            if Me.lexer.options.target = "c" Then
            
                '.intoVar = UniqueID.getVarName('__or')
                Me.intoVar = UniqueID.getVarName("__or")
            
            End if
            
        
        'else if .name is 'or'
        
        elseif Me.name = "isnt" Then
        
          '.negated = true # set the 'negated' flag
          Me.negated = true
          '.name = 'is' # treat as 'Negated is'
          Me.name = "is"
        
        'else if .name is 'isnt'
        
        elseif Me.name = "instanceof" Then
        
          '.name = 'instance of'
          Me.name = "instance of"
        
        End if
        End if
        End if
        End if

        'end if

'C) Variants on 'is/isnt...'

        'if .name is 'is' # note: 'isnt' was converted to 'is {negated:true}' above
        

'C) Variants on 'is/isnt...'

        'if .name is 'is' # note: 'isnt' was converted to 'is {negated:true}' above
        if Me.name = "is" Then
        

  'C.1) is not<br>
  'Check for `is not`, which we treat as `isnt` rather than `is ( not`.

            'if .opt('not') # --> is not/has not...
            if Me.opt("not") Then
            
                'if .negated, .throwError '"isnt not" is invalid'
                if Me.negated Then Me.throwError(""isnt not" is invalid")
                '.negated = true # set the 'negated' flag
                Me.negated = true
            
            End if

            'end if

  'C.2) accept 'is/isnt instance of' and 'is/isnt instanceof'

            'if .opt('instance')
            

  'C.2) accept 'is/isnt instance of' and 'is/isnt instanceof'

            'if .opt('instance')
            if Me.opt("instance") Then
            
                '.req('of')
                Me.req("of")
                '.name = 'instance of'
                Me.name = "instance of"
            
            'if .opt('instance')
            
            elseif Me.opt("instanceof") Then
            
                '.name = 'instance of'
                Me.name = "instance of"
            
            End if
            End if

            'end if

'Get operator precedence index

        '.getPrecedence
            
        
        End if

'Get operator precedence index

        '.getPrecedence
        Me.getPrecedence()
      end function
      ' ---------------------------
      Public Function getPrecedence ()

        '.precedence = operatorsPrecedence.indexOf(.name)
        Me.precedence = operatorsPrecedence.indexOf(Me.name)
        'if .precedence is -1
        if Me.precedence = -1 Then
        
            'debugger
            debugger
            '.sayErr "OPER '#{.name}' not found in the operator precedence list"
            Me.sayErr("OPER '" + Me.name + "' not found in the operator precedence list")
        
        End if
        
      end function
    
    end class 'Oper



'###Boolean Negation: `not`

'####Notes for the javascript programmer

'In LiteScript, *the boolean negation* `not`,
'has LOWER PRECEDENCE than the arithmetic and logical operators.

'In LiteScript:  `if not a + 2 is 5` means `if not (a+2 is 5)`

'In javascript: `if ( ! a + 2 === 5 )` means `if ( (!a)+2 === 5 )`

'so remember **not to** mentally translate `not` to js `!`


'UnaryOper
'---------

'`UnaryOper: ('-'|'+'|new|type of|typeof|not|no|bitnot)`

'A Unary Oper is an operator acting on a single operand.
'Unary Oper extends Oper, so both are `instance of Oper`

'Examples:

'1 `not`     *boolean negation*     `if not ( a is 3 or b is 4)`
'2. `-`       *numeric unary minus*  `-(4+3)`
'2. `+`       *numeric unary plus*   `+4` (can be ignored)
'3. `new`     *instantiation*        `x = new classes[2]()`
'4. `type of` *type name access*     `type of x is 'string'`
'5. `no`      *'falsey' check*       `if no options then options={}`
'6. `~`       *bit-unary-negation*   `a = ~xC0 + 5`

    'var unaryOperators = ['new','-','no','not','type','typeof','bitnot','+']
    Dim unaryOperators = new ArrayList From {"new", "-", "no", "not", "type", "typeof", "bitnot", "+"}

    'public class UnaryOper extends Oper
    ' constructor
    Class UnaryOper
    Inherits Oper
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
          '.name = .reqOneOf(unaryOperators)
          Me.name = Me.reqOneOf(unaryOperators)

'Check for `type of` - we allow "type" as var name, but recognize "type of" as UnaryOper

          'if .name is 'type'
          if Me.name = "type" Then
          
              'if .opt('of')
              if Me.opt("of") Then
              
                '.name = 'type of'
                Me.name = "type of"
              
              'if .opt('of')
              
              else
              
                '.throwParseFailed 'expected "of" after "type"'
                Me.throwParseFailed("expected "of" after "type"")
              
              End if
              
          
          End if

'Lock, we have a unary oper

          '.lock()
          Me.lock()

'Rename - and + to 'unary -' and 'unary +',
''typeof' to 'type of'

          'if .name is '-'
          if Me.name = "-" Then
          
              '.name = 'unary -'
              Me.name = "unary -"
          
          'if .name is '-'
          
          elseif Me.name = "+" Then
          
              '.name = 'unary +'
              Me.name = "unary +"
          
          'else if .name is '+'
          
          elseif Me.name = "typeof" Then
          
              '.name = 'type of'
              Me.name = "type of"
          
          End if
          End if
          End if

          'end if

'calculate precedence - Oper.getPrecedence()

          '.getPrecedence()
          

'calculate precedence - Oper.getPrecedence()

          '.getPrecedence()
          Me.getPrecedence()
      end function
    
    end class 'UnaryOper


'-----------
'## Expression

'`Expression: [UnaryOper] Operand [Oper [UnaryOper] Operand]*`

'The expression class parses intially a *flat* array of nodes.
'After the expression is parsed, a *Expression Tree* is created based on operator precedence.

    'public class Expression extends ASTBase
    ' constructor
    Class Expression
    Inherits ASTBase
        Public Property operandCount as Object
          Public Property root as Object
          Public Property ternaryCount as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        'declare valid .growExpressionTree
        
        'declare valid .root.name.type
        

        'var arr = []
        Dim arr = new ArrayList
        '.operandCount = 0
        Me.operandCount = 0
        '.ternaryCount = 0
        Me.ternaryCount = 0

        'do
        Do whiletrue
        

'Get optional unary operator
'(performance) check token first

            'if .lexer.token.value in unaryOperators
            if unaryOperators.Contains(Me.lexer.token.value) Then
            
                'var unaryOper = .opt(UnaryOper)
                Dim unaryOper = Me.opt(UnaryOper)
                'if unaryOper
                if unaryOper Then
                
                    'arr.push unaryOper
                    arr.push(unaryOper)
                    '.lock()
                    Me.lock()
                
                End if
                
            
            End if

'Get operand

            'arr.push .req(Operand)
            arr.push(Me.req(Operand))
            '.operandCount++
            Me.operandCount++
            '.lock()
            Me.lock()

'(performance) Fast exit for common tokens: `= , ] )` -> end of expression.

            'if .lexer.token.type is 'ASSIGN' or .lexer.token.value in ',)]'
            if Me.lexer.token.type = "ASSIGN" OrElse ",)]".Contains(Me.lexer.token.value) Then
            
                'break
                break
            
            End if

'optional newline **before** `Oper`
'to allow a expressions to continue on the next line.
'We look ahead, and if the first token in the next line is OPER
'we consume the NEWLINE, allowing multiline expressions.
'The exception is ArrayLiteral, because in free-form mode
'the next item in the array on the next line, can start with a unary operator

            'if .lexer.token.type is 'NEWLINE' and not (.parent instanceof ArrayLiteral)
            if Me.lexer.token.type = "NEWLINE" AndAlso Not((TypeOf Me.parent is ArrayLiteral)) Then
            
              '.opt 'NEWLINE' #consume newline
              Me.opt("NEWLINE")
              'if .lexer.token.type isnt 'OPER' # the first token in the next line isnt OPER (+,and,or,...)
              if Me.lexer.token.type <> "OPER" Then
              
                  '.lexer.returnToken() # return NEWLINE
                  Me.lexer.returnToken()
                  'break #end Expression
                  break
              
              End if
              
            
            End if

'Try to parse next token as an operator

            'var oper = .opt(Oper)
            Dim oper = Me.opt(Oper)
            'if no oper then break # no more operators, end of expression
            if Notoper Then break

'keep count on ternaryOpers

            'if oper.name is '?'
            if oper.name = "?" Then
            
                '.ternaryCount++
                Me.ternaryCount++
            
            'if oper.name is '?'
            
            elseif oper.name = ":" Then
            
                'if no .ternaryCount //":" without '?'. It can be 'case' expression ending ":"
                if NotMe.ternaryCount Then
                
                    '.lexer.returnToken
                    Me.lexer.returnToken()
                    'break //end of expression
                    break
                
                End if
                '.ternaryCount--
                Me.ternaryCount--
            
            End if
            End if

            'end if

'If it was an operator, store, and continue because we expect another operand.
'(operators sits between two operands)

            'arr.push(oper)
            

'If it was an operator, store, and continue because we expect another operand.
'(operators sits between two operands)

            'arr.push(oper)
            arr.push(oper)

'allow dangling expression. If the line ends with OPER,
'we consume the NEWLINE and continue parsing the expression on the next line

            '.opt 'NEWLINE' #consume optional newline after Oper
            Me.opt("NEWLINE")
        
        Loop

'Control: complete all ternary operators

        'if .ternaryCount, .throwError 'missing (":"|else) on ternary operator (a? b else c)'
        if Me.ternaryCount Then Me.throwError("missing (":"|else) on ternary operator (a? b else c)")

'Fix 'new' calls. Check parameters for 'new' unary operator, for consistency, add '()' if not present,
'so `a = new MyClass` turns into `a = new MyClass()`

        'for each index,item in arr
        Dim index as Integer =0
        For Each item in arr
        
          'declare item:UnaryOper
          
          'if item instanceof UnaryOper and item.name is 'new'
          if TypeOf item is UnaryOper AndAlso item.name = "new" Then
          
            'var operand = arr[index+1]
            Dim operand = arr(index + 1)
            'if operand.name instanceof VariableRef
            if TypeOf operand.name is VariableRef Then
            
                'var varRef = operand.name
                Dim varRef = operand.name
                'if no varRef.executes, varRef.addAccessor new FunctionAccess(this)
                if NotvarRef.executes Then varRef.addAccessor(new FunctionAccess(Me))
            
            End if
            
          
          End if
          
        Next'  each in arr

'Now we create a tree from .arr[], based on operator precedence

        '.growExpressionTree(arr)
        Me.growExpressionTree(arr)
      end function
      ' ---------------------------
      Public Function growExpressionTree (arr)

        'do while arr.length > 1
        Do whilearr.length > 1
        

'find the one with highest precedence (lower number) to push down
'(on equal precedende, we use the leftmost)

          'var pos=-1
          Dim pos = -1
          'var minPrecedenceInx = 100
          Dim minPrecedenceInx = 100
          'for each inx,item in arr
          Dim inx as Integer =0
          For Each item in arr
          

              '//debug "item at #{inx} #{item.name}, Oper? #{item instanceof Oper}. precedence:",item.precedence

              'if item instanceof Oper
              if TypeOf item is Oper Then
              
                  'declare item:Oper
                  
                  'if not item.pushed and item.precedence < minPrecedenceInx
                  if Not(item.pushed) AndAlso item.precedence < minPrecedenceInx Then
                  
                      'pos = inx
                      pos = inx
                      'minPrecedenceInx = item.precedence
                      minPrecedenceInx = item.precedence
                  
                  End if
                  
              
              End if
              
          Next'  each in arr

          'end for

          '#control
          'if pos<0, .throwError("can't find highest precedence operator")
          

          '#control
          'if pos<0, .throwError("can't find highest precedence operator")
          if pos < 0 Then Me.throwError("can't find highest precedence operator")

'Un-flatten: Push down the operands a level down

          'var oper = arr[pos]
          Dim oper = arr(pos)

          'oper.pushed = true
          oper.pushed = true

          'if oper instanceof UnaryOper
          if TypeOf oper is UnaryOper Then
          

              '#control
              'if pos is arr.length
              if pos = arr.length Then
              
                  '.throwError("can't get RIGHT operand for unary operator '#{oper}'")
                  Me.throwError("can't get RIGHT operand for unary operator '" + oper + "'")
              
              End if

              '# if it's a unary operator, take the only (right) operand, and push-it down the tree
              'oper.right = arr.splice(pos+1,1)[0]
              oper.right = arr.splice(pos + 1, 1)(0)
          
          'if oper instanceof UnaryOper
          
          else
          

              '#control
              'if pos is arr.length
              if pos = arr.length Then
              
                '.throwError("can't get RIGHT operand for binary operator '#{oper}'")
                Me.throwError("can't get RIGHT operand for binary operator '" + oper + "'")
              
              End if
              'if pos is 0
              if pos = 0 Then
              
                '.throwError("can't get LEFT operand for binary operator '#{oper}'")
                Me.throwError("can't get LEFT operand for binary operator '" + oper + "'")
              
              End if

              '# if it's a binary operator, take the left and right operand, and push them down the tree
              'oper.right = arr.splice(pos+1,1)[0]
              oper.right = arr.splice(pos + 1, 1)(0)
              'oper.left = arr.splice(pos-1,1)[0]
              oper.left = arr.splice(pos - 1, 1)(0)
          
          End if

          'end if

        'loop #until there's only one operator
          
        
        Loop

'Store the root operator

        '.root = arr[0]
        Me.root = arr(0)
      end function
    
    end class 'Expression

'-----------------------

'## Literal

'This class groups: NumberLiteral, StringLiteral, RegExpLiteral, ArrayLiteral and ObjectLiteral

    'public class Literal extends ASTBase
    ' constructor
    Class Literal
    Inherits ASTBase
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function getValue ()
        'return .name
        return Me.name
      end function
      ' ---------------------------
      Public Function toString ()
        'return .name
        return Me.name
      end function
    
    end class 'Literal


'## NumberLiteral

'`NumberLiteral: NUMBER`

'A numeric token constant. Can be anything the lexer supports, including scientific notation
', integers, floating point, or hex.

    'public class NumberLiteral extends Literal
    ' constructor
    Class NumberLiteral
    Inherits Literal
    
    Sub New()
    ' default constructor: call super.constructor
        MyBase.New()
        '.type = 'Number'
        Me.type = "Number"
      end function
    
      ' ---------------------------
      Public Function parse ()
        '.name = .req('NUMBER')
        Me.name = Me.req("NUMBER")
      end function
    
    end class 'NumberLiteral


'## StringLiteral

'`StringLiteral: STRING`

'A string constant token. Can be anything the lexer supports, including single or double-quoted strings.
'The token include the enclosing quotes

    'public class StringLiteral extends Literal
    ' constructor
    Class StringLiteral
    Inherits Literal
    
    Sub New()
    ' default constructor: call super.constructor
        MyBase.New()
        '.type = 'String'
        Me.type = "String"
      end function
    
      ' ---------------------------
      Public Function parse ()
        '.name = .req('STRING')
        Me.name = Me.req("STRING")
      end function
      ' ---------------------------
      Public Function getValue ()
        'return .name.slice(1,-1) #remove quotes
        return Me.name.slice(1, -1)
      end function
    
    end class 'StringLiteral

'## RegExpLiteral

'`RegExpLiteral: REGEX`

'A regular expression token constant. Can be anything the lexer supports.

    'public class RegExpLiteral extends Literal
    ' constructor
    Class RegExpLiteral
    Inherits Literal
    
    Sub New()
    ' default constructor: call super.constructor
        MyBase.New()
        '.type = 'RegExp'
        Me.type = "RegExp"
      end function
    
      ' ---------------------------
      Public Function parse ()
        '.name = .req('REGEX')
        Me.name = Me.req("REGEX")
      end function
    
    end class 'RegExpLiteral


'## ArrayLiteral

'`ArrayLiteral: '[' (Expression,)* ']'`

'An array definition, such as `a = [1,2,3]`
'or

'```
'a = [
   '"January"
   '"February"
   '"March"
  ']
'```

    'public class ArrayLiteral extends Literal
    ' constructor
    Class ArrayLiteral
    Inherits Literal
        Public Property items as Array' mainType: Array  ' itemType: Expression
      
    
    Sub New()
    ' default constructor: call super.constructor
        MyBase.New()
        '.type = 'Array'
        Me.type = "Array"
      end function
    
      ' ---------------------------
      Public Function parse ()
        '.req '[','SPACE_BRACKET'
        Me.req("[", "SPACE_BRACKET")
        '.lock()
        Me.lock()
        '.items = .optSeparatedList(Expression,',',']') # closer "]" required
        Me.items = Me.optSeparatedList(Expression, ",", "]")
      end function
    
    end class 'ArrayLiteral


'## ObjectLiteral

'`ObjectLiteral: '{' NameValuePair* '}'`

'Defines an object with a list of key value pairs. This is a JavaScript-style definition.
'For LiteC (the Litescript-to-C compiler), a ObjectLiteral crates a `Map string to any` on the fly.

'`x = {a:1,b:2,c:{d:1}}`

    'public class ObjectLiteral extends Literal
    ' constructor
    Class ObjectLiteral
    Inherits Literal
        Public Property items as Array' mainType: Array  ' itemType: NameValuePair
      
          Public Property produceType as String' mainType: String  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req '{'
        Me.req("{")
        '.lock()
        Me.lock()
        '.items = .optSeparatedList(NameValuePair,',','}') # closer "}" required
        Me.items = Me.optSeparatedList(NameValuePair, ",", "}")
      end function
      ' ---------------------------
      Public Function forEach (callback)
          'for each nameValue in .items
          For Each nameValue in Me.items
          
            'nameValue.forEach(callback)
            nameValue.forEach(callback)
          Next'  each in Me.items
          
      end function
    
    end class 'ObjectLiteral


'## NameValuePair

'`NameValuePair: (IDENTIFIER|StringLiteral|NumberLiteral) ':' Expression`

'A single definition in a `ObjectLiteral`
'a `property-name: value` pair.

    'public class NameValuePair extends ASTBase
    ' constructor
    Class NameValuePair
    Inherits ASTBase
        Public Property value as Expression' mainType: Expression  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.name = .req('IDENTIFIER',StringLiteral,NumberLiteral)
        Me.name = Me.req("IDENTIFIER", StringLiteral, NumberLiteral)

        '.req ':'
        Me.req(":")
        '.lock()
        Me.lock()

'if it's a "dangling assignment", we assume FreeObjectLiteral

        'if .lexer.token.type is 'NEWLINE'
        if Me.lexer.token.type = "NEWLINE" Then
        
          '.value = .req(FreeObjectLiteral)
          Me.value = Me.req(FreeObjectLiteral)
        
        'if .lexer.token.type is 'NEWLINE'
        
        else
        
          'if .lexer.interfaceMode
          if Me.lexer.interfaceMode Then
          
              '.type = .req(TypeDeclaration)
              Me.type = Me.req(TypeDeclaration)
          
          'if .lexer.interfaceMode
          
          else
          
              '.value = .req(Expression)
              Me.value = Me.req(Expression)
          
          End if
          
        
        End if
        
      end function
      ' ---------------------------
      Public Function forEach (callback)

          'callback.call(this)
          callback.call(Me)

          'if .value.root.name instanceof ObjectLiteral
          if TypeOf Me.value.root.name is ObjectLiteral Then
          
            'declare .value.root.name:ObjectLiteral
            
            '.value.root.name.forEach callback # recurse
            Me.value.root.name.forEach(callback)
          
          End if
          
      end function
    
    end class 'NameValuePair


'## FreeObjectLiteral

'Defines an object with a list of key value pairs.
'Each pair can be in it's own line. A indent denotes a new level deep.
'FreeObjectLiterals are triggered by a "dangling assignment"

'Examples:
'
'
'    var x =            // <- dangling assignment
'          a: 1
'          b:           // <- dangling assignment
'            b1:"some"
'            b2:"latte"
'
'    var x =
'     a:1
'     b:2
'     c:
'      d:1
'     months: ["J","F",
'      "M","A","M","J",
'      "J","A","S","O",
'      "N","D" ]
'
'
'    var y =
'     c:{d:1}
'     trimester:[
'       "January"
'       "February"
'       "March"
'     ]
'     getValue: function(i)
'       return y.trimester[i]

    '    public class FreeObjectLiteral extends ObjectLiteral
    ' constructor
    Class FreeObjectLiteral
    Inherits ObjectLiteral
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.lock()
        Me.lock()
        '.items = .reqSeparatedList(NameValuePair,',')
        Me.items = Me.reqSeparatedList(NameValuePair, ",")
      end function
    
    end class 'FreeObjectLiteral


'## ParenExpression

'`ParenExpression: '(' Expression ')'`

'An expression enclosed by parentheses, like `(a + b)`.

    'public class ParenExpression extends ASTBase
    ' constructor
    Class ParenExpression
    Inherits ASTBase
        Public Property expr as Expression' mainType: Expression  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req '('
        Me.req("(")
        '.lock()
        Me.lock()
        '.expr = .req(Expression)
        Me.expr = Me.req(Expression)
        '.opt 'NEWLINE'
        Me.opt("NEWLINE")
        '.req ')'
        Me.req(")")
      end function
    
    end class 'ParenExpression


'## FunctionDeclaration

'`FunctionDeclaration: 'function [IDENTIFIER] ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`

'Functions: parametrized pieces of callable code.

    'public class FunctionDeclaration extends ASTBase
    ' constructor
    Class FunctionDeclaration
    Inherits ASTBase
        Public Property specifier as Object
          Public Property paramsDeclarations as FunctionParameters' mainType: FunctionParameters  
      
          Public Property definePropItems as Array' mainType: Array  ' itemType: DefinePropertyItem
      
          Public Property body as Object
          Public Property hasExceptionBlock as Boolean' mainType: Boolean  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.specifier = .req('function','method','->')
        Me.specifier = Me.req("function", "method", "->")
        '.lock()
        Me.lock()

        'if .specifier isnt 'method' and .parent.parent instance of ClassDeclaration
        if Me.specifier <> "method" AndAlso TypeOf Me.parent.parent is ClassDeclaration Then
        
            '.throwError "unexpected 'function' in 'class/namespace' body. You should use 'method'"
            Me.throwError("unexpected 'function' in 'class/namespace' body. You should use 'method'")
        
        End if

''->' are anonymous functions

        'if .specifier is '->'
        if Me.specifier = "->" Then
        
            '.name = ""
            Me.name = ""
        
        'if .specifier is '->'
        
        else
        
            '.name = .opt('IDENTIFIER')
            Me.name = Me.opt("IDENTIFIER")
            'if .name in ['__init','new'], .sayErr '"#{.name}" is a reserved function name'
            if new ArrayList From {"__init", "new"}
            .Contains(Me.name) Then Me.sayErr(""" + Me.name + "" is a reserved function name")
        
        End if

'get parameter members, and function body

        '.parseParametersAndBody
        Me.parseParametersAndBody()
      end function
      ' ---------------------------
      Public Function parseParametersAndBody ()

'This method is shared by functions, methods and constructors.
'`()` after `function` are optional. It parses: `['(' [VariableDecl,] ')'] [returns VariableRef] '['DefinePropertyItem']'`

'get parameters declarations

        '.paramsDeclarations = .opt(FunctionParameters)
        Me.paramsDeclarations = Me.opt(FunctionParameters)

'now parse body

        'if .opt('=') #one line function. Body is a Expression
        if Me.opt("=") Then
        
            '.body = .req(Expression)
            Me.body = Me.req(Expression)
        
        'if .opt('=') #one line function. Body is a Expression
        
        else
        

            'if .opt('returns'), .type = .req(TypeDeclaration)  #function return type
            if Me.opt("returns") Then Me.type = Me.req(TypeDeclaration)

            'if .opt('[','SPACE_BRACKET') # property attributes (non-enumerable, writable, etc - Object.defineProperty)
            if Me.opt("[", "SPACE_BRACKET") Then
            
                '.definePropItems = .optSeparatedList(DefinePropertyItem,',',']')
                Me.definePropItems = Me.optSeparatedList(DefinePropertyItem, ",", "]")
            
            End if

            '#indented function body
            '.body = .req(Body)
            Me.body = Me.req(Body)
        
        End if

        'end if


    '    public class DefinePropertyItem extends ASTBase
        
      end function
    
    end class 'FunctionDeclaration


    '    public class DefinePropertyItem extends ASTBase
    ' constructor
    Class DefinePropertyItem
    Inherits ASTBase
        Public Property negated as Boolean' mainType: Boolean  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.lock()
        Me.lock()
        '.negated = .opt('not')
        Me.negated = Me.opt("not")
        '.name = .req('enumerable','configurable','writable')
        Me.name = Me.req("enumerable", "configurable", "writable")
      end function
    
    end class 'DefinePropertyItem



'## MethodDeclaration

'`MethodDeclaration: 'method [name] ["(" [VariableDecl,] ")"] [returns type-VariableRef] ["["DefinePropertyItem,"]"] Body`

'A `method` is a function defined in the prototype of a class.
'A `method` has an implicit var `this` pointing to the specific instance the method is called on.

'MethodDeclaration derives from FunctionDeclaration, so both are instance of FunctionDeclaration

'Examples:
'<br>`method concat(a:string, b:string) return string`
'<br>`method remove(element) [not enumerable, not writable, configurable]`

    'public class MethodDeclaration extends FunctionDeclaration
    ' constructor
    Class MethodDeclaration
    Inherits FunctionDeclaration
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.specifier = .req('method')
        Me.specifier = Me.req("method")
        '.lock()
        Me.lock()

'require method name. Note: jQuery uses 'not' and 'has' as method names, so here we
'take any token, and then check if it's a valid identifier

        '//.name = .req('IDENTIFIER')
        'var name = .lexer.token.value
        Dim name = Me.lexer.token.value

        'if no PMREX.whileRanges(name,"0-9") and name is PMREX.whileRanges(name,"a-zA-Z0-9$_")
        if NotPMREX.whileRanges(name, "0-9") AndAlso name = PMREX.whileRanges(name, "a-zA-Z0-9$_") Then
        
            'do nothing //if do no start with a number and it's composed by "a-zA-Z0-9$_", is valid
            Do Nothing
        
        'if no PMREX.whileRanges(name,"0-9") and name is PMREX.whileRanges(name,"a-zA-Z0-9$_")
        
        else
        
            '.throwError 'invalid method name: "#{name}"'
            Me.throwError("invalid method name: "" + name + """)
        
        End if

        '.name = name
        Me.name = name
        '.lexer.nextToken
        Me.lexer.nextToken()

'now parse parameters and body (as with any function)

        '.parseParametersAndBody
        Me.parseParametersAndBody()
      end function
    
    end class 'MethodDeclaration


'## ClassDeclaration

'`ClassDeclaration: class IDENTIFIER [[","] (extends|inherits from)] Body`

'Defines a new class with an optional parent class. properties and methods go inside the block.

    'public class ClassDeclaration extends ASTBase
    ' constructor
    Class ClassDeclaration
    Inherits ASTBase
        Public Property varRefSuper as VariableRef' mainType: VariableRef  
      
          Public Property body as Object
          Public Property constructorDeclaration as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'class'
        Me.req("class")
        '.lock()
        Me.lock()
        '.name = .req('IDENTIFIER')
        Me.name = Me.req("IDENTIFIER")

'Control: class names should be Capitalized, except: jQuery

        'if not .lexer.interfaceMode and not String.isCapitalized(.name)
        if Not(Me.lexer.interfaceMode) AndAlso Not(String.isCapitalized(Me.name)) Then
        
            '.lexer.sayErr "class names should be Capitalized: class #{.name}"
            Me.lexer.sayErr("class names should be Capitalized: class " + Me.name)
        
        End if

'Now parse optional `,(extend|proto is|inherits from)` setting the super class

        '.opt(',')
        Me.opt(",")
        'if .opt('extends','inherits','proto')
        if Me.opt("extends", "inherits", "proto") Then
        
          '.opt('from','is')
          Me.opt("from", "is")
          '.varRefSuper = .req(VariableRef)
          Me.varRefSuper = Me.req(VariableRef)
        
        End if

'Now get the class body

        '.body = .req(Body)
        Me.body = Me.req(Body)
        '.body.validate
            'PropertiesDeclaration, ConstructorDeclaration
            'MethodDeclaration, DeclareStatement, DoNothingStatement


'## ConstructorDeclaration

'`ConstructorDeclaration : 'constructor [new className-IDENTIFIER] ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`

'A `constructor` is the main function of the class. In js is the function-class body  (js: `function Class(...){... `)
'The `constructor` method is called upon creation of the object, by the `new` operator.
'The return value is the value returned by `new` operator, that is: the new instance of the class.

'ConstructorDeclaration derives from MethodDeclaration, so it is also a instance of FunctionDeclaration

    'public class ConstructorDeclaration extends MethodDeclaration
        Me.body.validate(PropertiesDeclaration, ConstructorDeclaration, MethodDeclaration, DeclareStatement, DoNothingStatement)
      end function
    
    end class 'ClassDeclaration


'## ConstructorDeclaration

'`ConstructorDeclaration : 'constructor [new className-IDENTIFIER] ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`

'A `constructor` is the main function of the class. In js is the function-class body  (js: `function Class(...){... `)
'The `constructor` method is called upon creation of the object, by the `new` operator.
'The return value is the value returned by `new` operator, that is: the new instance of the class.

'ConstructorDeclaration derives from MethodDeclaration, so it is also a instance of FunctionDeclaration

    'public class ConstructorDeclaration extends MethodDeclaration
    ' constructor
    Class ConstructorDeclaration
    Inherits MethodDeclaration
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.specifier = .req('constructor')
        Me.specifier = Me.req("constructor")
        '.lock()
        Me.lock()

        '.name = '__init'
        Me.name = "__init"

        'if .opt('new') # optional: constructor new Person(name:string)
        if Me.opt("new") Then
        
          '# to ease reading, and to find also the constructor when searching for "new Person"
          'var className = .req('IDENTIFIER')
          Dim className = Me.req("IDENTIFIER")
          'var classDeclaration = .getParent(ClassDeclaration)
          Dim classDeclaration = Me.getParent(ClassDeclaration)
          'if no classDeclaration, . sayErr "constructor found outside Class Declaration"
          if NotclassDeclaration Then Me.sayErr("constructor found outside Class Declaration")
          'if classDeclaration and classDeclaration.name isnt className
          if classDeclaration AndAlso classDeclaration.name <> className Then
          
              '.sayErr "Class Name mismatch #{className}/#{classDeclaration.name}"
              Me.sayErr("Class Name mismatch " + className + "/" + classDeclaration.name)
          
          End if
          
        
        End if

'now get parameters and body (as with any function)

        '.parseParametersAndBody
        Me.parseParametersAndBody()

'Check we're in a class, set class property:constructorDeclaration

        'var bodyParent =  .parent.parent.parent // =>Statement=>Body=>Body's parent
        Dim bodyParent = Me.parent.parent.parent
        'if bodyParent.constructor isnt ClassDeclaration
        if bodyParent.constructor <> ClassDeclaration Then
        
            '.sayErr "constructor outside class. Container is: #{bodyParent}"
            Me.sayErr("constructor outside class. Container is: " + bodyParent)
        
        End if

        'declare bodyParent:ClassDeclaration
        
        'if bodyParent.constructorDeclaration
        if bodyParent.constructorDeclaration Then
        
            '.sayErr "this class already has a constructor"
            Me.sayErr("this class already has a constructor")
        
        End if
        'bodyParent.constructorDeclaration = this
        bodyParent.constructorDeclaration = Me
      end function
    
    end class 'ConstructorDeclaration

      '#end parse

'------------------------------

'## AppendToDeclaration

'`AppendToDeclaration: append to (class|object) VariableRef Body`

'Adds methods and properties to an existent object, e.g., Class.prototype

    'public class AppendToDeclaration extends ClassDeclaration
    ' constructor
    Class AppendToDeclaration
    Inherits ClassDeclaration
        Public Property toNamespace as Object
          Public Property varRef as VariableRef' mainType: VariableRef  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'append','Append'
        Me.req("append", "Append")
        '.req 'to'
        Me.req("to")
        '.lock()
        Me.lock()

        'var appendToWhat:string = .req('class','Class','namespace','Namespace')
        Dim appendToWhat = Me.req("class", "Class", "namespace", "Namespace")
        '.toNamespace = appendToWhat.endsWith('space')
        Me.toNamespace = appendToWhat.endsWith("space")

        '.varRef = .req(VariableRef)
        Me.varRef = Me.req(VariableRef)

        'if .toNamespace, .name=.varRef.toString()
        if Me.toNamespace Then Me.name = Me.varRef.toString()

'Now get the append-to body

        '.body = .req(Body)
        Me.body = Me.req(Body)

        '.body.validate
            'PropertiesDeclaration
            'MethodDeclaration
            'ClassDeclaration


'## NamespaceDeclaration

'`NamespaceDeclaration: namespace IDENTIFIER Body`

'Declares a namespace.
'for js: creates a object with methods and properties
'for LiteC, just declare a namespace. All classes created inside will have the namespace prepended with "_"

    'public class NamespaceDeclaration extends ClassDeclaration // NamespaceDeclaration is instance of ClassDeclaration
        Me.body.validate(PropertiesDeclaration, MethodDeclaration, ClassDeclaration)
      end function
    
    end class 'AppendToDeclaration


'## NamespaceDeclaration

'`NamespaceDeclaration: namespace IDENTIFIER Body`

'Declares a namespace.
'for js: creates a object with methods and properties
'for LiteC, just declare a namespace. All classes created inside will have the namespace prepended with "_"

    'public class NamespaceDeclaration extends ClassDeclaration // NamespaceDeclaration is instance of ClassDeclaration
    ' constructor
    Class NamespaceDeclaration
    Inherits ClassDeclaration
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'namespace','Namespace'
        Me.req("namespace", "Namespace")

        '.lock()
        Me.lock()
        '.name=.req('IDENTIFIER')
        Me.name = Me.req("IDENTIFIER")

'Now get the namespace body

        '.body = .req(Body)
        Me.body = Me.req(Body)

        '.body.validate
            'PropertiesDeclaration
            'MethodDeclaration
            'ClassDeclaration
            'NamespaceDeclaration


'## DebuggerStatement

'`DebuggerStatement: debugger`

'When a debugger is attached, break at this point.

    'public class DebuggerStatement extends ASTBase
        Me.body.validate(PropertiesDeclaration, MethodDeclaration, ClassDeclaration, NamespaceDeclaration)
      end function
    
    end class 'NamespaceDeclaration


'## DebuggerStatement

'`DebuggerStatement: debugger`

'When a debugger is attached, break at this point.

    'public class DebuggerStatement extends ASTBase
    ' constructor
    Class DebuggerStatement
    Inherits ASTBase
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.name = .req("debugger")
        Me.name = Me.req("debugger")
      end function
    
    end class 'DebuggerStatement



'CompilerStatement
'-----------------

'`compiler` is a generic entry point to alter LiteScript compiler from source code.
'It allows conditional complilation, setting compiler options, and execute macros
'to generate code on the fly.
'Future: allow the programmer to hook transformations on the compiler process itself.
'<br>`CompilerStatement: (compiler|compile) (set|if|debugger|option) Body`
'<br>`set-CompilerStatement: compiler set (VariableDecl,)`
'<br>`conditional-CompilerStatement: 'compile if IDENTIFIER Body`

    'public class CompilerStatement extends ASTBase
    ' constructor
    Class CompilerStatement
    Inherits ASTBase
        Public Property kind as Object
          Public Property conditional as String' mainType: String  
      
          Public Property list as Object
          Public Property body as Object
          Public Property endLineInx as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req 'compiler','compile'
        Me.req("compiler", "compile")
        '.lock()
        Me.lock()

        '.kind = .req('set','if','debugger','options')
        Me.kind = Me.req("set", "if", "debugger", "options")

'### compiler set
'get list of declared names, add to root node 'Compiler Vars'

        'if .kind is 'set'
        if Me.kind = "set" Then
        
            '.list = .reqSeparatedList(VariableDecl,',')
            Me.list = Me.reqSeparatedList(VariableDecl, ",")
        
        'if .kind is 'set'
        
        elseif Me.kind = "debugger" Then
        
          'debugger
          debugger
        
        'else if .kind is 'debugger' #debug-pause the compiler itself, to debug compiling process
        
        else
        
          '.sayErr 'invalid compiler command'
          Me.sayErr("invalid compiler command")
        
        End if
        End if
        
      end function
    
    end class 'CompilerStatement


'## Import Statement

'`ImportStatement: import (ImportStatementItem,)`

'Example: `import fs, path` ->  js:`var fs=require('fs'),path=require('path')`

'Example: `import Args, wait from 'wait.for'` ->  js:`var http=require('./Args'),wait=require('./wait.for')`

    'public class ImportStatement extends ASTBase
    ' constructor
    Class ImportStatement
    Inherits ASTBase
        Public Property global as Boolean' mainType: Boolean  
      
          Public Property list as Array' mainType: Array  ' itemType: ImportStatementItem
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.req('import')
        Me.req("import")
        '.lock
        Me.lock()

        'if .lexer.options.browser, .throwError "'import' statement invalid in browser-mode. Do you mean 'global declare'?"
        if Me.lexer.options.browser Then Me.throwError("'import' statement invalid in browser-mode. Do you mean 'global declare'?")

        '.list = .reqSeparatedList(ImportStatementItem,",")
        Me.list = Me.reqSeparatedList(ImportStatementItem, ",")

'keep track of `import/require` calls

        'var parentModule = .getParent(Module)
        Dim parentModule = Me.getParent(Module)
        'for each item in .list
        For Each item in Me.list
        
            'parentModule.requireCallNodes.push item
            parentModule.requireCallNodes.push(item)
        Next'  each in Me.list
        
      end function
    
    end class 'ImportStatement


    '    export class ImportStatementItem extends ASTBase
    ' constructor
    Class ImportStatementItem
    Inherits ASTBase
        Public Property importParameter as StringLiteral' mainType: StringLiteral  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()
        '.name = .req('IDENTIFIER')
        Me.name = Me.req("IDENTIFIER")
        'if .opt('from')
        if Me.opt("from") Then
        
            '.lock()
            Me.lock()
            '.importParameter = .req(StringLiteral)
            Me.importParameter = Me.req(StringLiteral)
        
        End if
        'end if

'## DeclareStatement

'Declare allows you to define a variable and/or its type
'*for the type-checker (at compile-time)*

'#####Declare variable:type
'`DeclareStatement: declare VariableRef:type-VariableRef`

'Declare a variable type on the fly, from declaration point onward

'Example: `declare name:string, parent:Grammar.Statement` #on the fly, from declaration point onward


'#####Global Declare
'`global declare (ImportStatementItem+)`
'Browser-mode: Import a *.interface.md* file to declare a global pre-existent complex objects
'Example: `global declare jQuery,Document,Window`

'#####Declare [global] var
'`DeclareStatement: declare [global] var (VariableDecl,)+`

'Allows you to declare a preexistent [global] variable
'Example: `declare global var window:object`

'#####Declare global type for VariableRef

'Allows you to set the type on a existing variable
'globally for the entire compilation.

'Example:
'`declare global type for LocalData.user: Models.userData` #set type globally for the entire compilation


'#####Declare name affinity
'`DeclareStatement: name affinity (IDENTIFIER,)+`

'To be used inside a class declaration, declare var names
'that will default to Class as type

'Example
'```
  'Class VariableDecl
    'properties
      'name: string, sourceLine, column
      'declare name affinity varDecl
'```

'Given the above declaration, any `var` named (or ending in) **"varDecl"** or **"VariableDecl"**
'will assume `:VariableDecl` as type. (Class name is automatically included in 'name affinity')

'Example:
'`var varDecl, parentVariableDecl, childVarDecl, variableDecl`

'all three vars will assume `:VariableDecl` as type.

'#####Declare valid
'`DeclareStatement: declare valid IDENTIFIER("."(IDENTIFIER|"()"|"[]"))* [:type-VariableRef]`

'To declare, on the fly, known-valid property chains for local variables.
'Example:
  '`declare valid data.user.name`
  '`declare valid node.parent.parent.text:string`
  '`declare valid node.parent.items[].name:string`

'#####Declare on
'`DeclareStatement: declare on IDENTIFIER (VariableDecl,)+`

'To declare valid members on scope vars.
'Allows you to declare the valid properties for a local variable or parameter
'Example:
'
'    function startServer(options)
'        declare on options
'            name:string, useHeaders:boolean, port:number


    '    export class DeclareStatement extends ASTBase
        
      end function
    
    end class 'ImportStatementItem

'## DeclareStatement

'Declare allows you to define a variable and/or its type
'*for the type-checker (at compile-time)*

'#####Declare variable:type
'`DeclareStatement: declare VariableRef:type-VariableRef`

'Declare a variable type on the fly, from declaration point onward

'Example: `declare name:string, parent:Grammar.Statement` #on the fly, from declaration point onward


'#####Global Declare
'`global declare (ImportStatementItem+)`
'Browser-mode: Import a *.interface.md* file to declare a global pre-existent complex objects
'Example: `global declare jQuery,Document,Window`

'#####Declare [global] var
'`DeclareStatement: declare [global] var (VariableDecl,)+`

'Allows you to declare a preexistent [global] variable
'Example: `declare global var window:object`

'#####Declare global type for VariableRef

'Allows you to set the type on a existing variable
'globally for the entire compilation.

'Example:
'`declare global type for LocalData.user: Models.userData` #set type globally for the entire compilation


'#####Declare name affinity
'`DeclareStatement: name affinity (IDENTIFIER,)+`

'To be used inside a class declaration, declare var names
'that will default to Class as type

'Example
'```
  'Class VariableDecl
    'properties
      'name: string, sourceLine, column
      'declare name affinity varDecl
'```

'Given the above declaration, any `var` named (or ending in) **"varDecl"** or **"VariableDecl"**
'will assume `:VariableDecl` as type. (Class name is automatically included in 'name affinity')

'Example:
'`var varDecl, parentVariableDecl, childVarDecl, variableDecl`

'all three vars will assume `:VariableDecl` as type.

'#####Declare valid
'`DeclareStatement: declare valid IDENTIFIER("."(IDENTIFIER|"()"|"[]"))* [:type-VariableRef]`

'To declare, on the fly, known-valid property chains for local variables.
'Example:
  '`declare valid data.user.name`
  '`declare valid node.parent.parent.text:string`
  '`declare valid node.parent.items[].name:string`

'#####Declare on
'`DeclareStatement: declare on IDENTIFIER (VariableDecl,)+`

'To declare valid members on scope vars.
'Allows you to declare the valid properties for a local variable or parameter
'Example:
'
'    function startServer(options)
'        declare on options
'            name:string, useHeaders:boolean, port:number


    '    export class DeclareStatement extends ASTBase
    ' constructor
    Class DeclareStatement
    Inherits ASTBase
        Public Property varRef as VariableRef' mainType: VariableRef  
      
          Public Property names as Array' mainType: Array  ' itemType: VariableDecl
      
          Public Property list as Array' mainType: Array  ' itemType: ImportStatementItem
      
          Public Property specifier as Object
          Public Property globVar as Boolean' mainType: Boolean  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'declare'
        Me.req("declare")
        '.lock()
        Me.lock()

'if it was 'global declare', treat as import statement

        'if .hasAdjective('global')
        if Me.hasAdjective("global") Then
        
              '.list = .reqSeparatedList(ImportStatementItem,",")
              Me.list = Me.reqSeparatedList(ImportStatementItem, ",")
              '//keep track of `import/require` calls
              'var parentModule = .getParent(Module)
              Dim parentModule = Me.getParent(Module)
              'for each item in .list
              For Each item in Me.list
              
                  'parentModule.requireCallNodes.push item
                  parentModule.requireCallNodes.push(item)
              Next'  each in Me.list
              'return
              return
        
        End if
        'end if

'get specifier 'on|valid|name|all'

        '.specifier = .opt('on','valid','name','global','var')
        

'get specifier 'on|valid|name|all'

        '.specifier = .opt('on','valid','name','global','var')
        Me.specifier = Me.opt("on", "valid", "name", "global", "var")
        'if .lexer.token.value is ':' #it was used as a var name
        if Me.lexer.token.value = ":" Then
        
            '.specifier='on-the-fly'
            Me.specifier = "on-the-fly"
            '.lexer.returnToken
            Me.lexer.returnToken()
        
        'if .lexer.token.value is ':' #it was used as a var name
        
        elseif NotMe.specifier Then
        
            '.specifier='on-the-fly' #no specifier => assume on-the-fly type assignment
            Me.specifier = "on-the-fly"
        
        End if
        End if
        'end if

        '#handle '...global var..' & '...global type for..'
        'if .specifier is 'global' #declare global (var|type for)...
        

        '#handle '...global var..' & '...global type for..'
        'if .specifier is 'global' #declare global (var|type for)...
        if Me.specifier = "global" Then
        
            '.specifier = .req('var','type') #require 'var|type'
            Me.specifier = Me.req("var", "type")
            'if .specifier is 'var'
            if Me.specifier = "var" Then
            
                  '.globVar = true
                  Me.globVar = true
            
            'if .specifier is 'var'
            
            else
            
                  '.req('for')
                  Me.req("for")
            
            End if
            
        
        End if
        'end if

        'case .specifier
        

        'case .specifier
        select Me.specifier
        case "on-the-fly","type"
        
            '#declare VarRef:Type
            '.varRef = .req(VariableRef)
            Me.varRef = Me.req(VariableRef)
            '.req(':') //type expected
            Me.req(":")
            '.type = .req(TypeDeclaration)
            Me.type = Me.req(TypeDeclaration)
        
        
        case "valid"
        
            '.varRef = .req(VariableRef)
            Me.varRef = Me.req(VariableRef)
            'if no .varRef.accessors, .sayErr "declare valid: expected accesor chain. Example: 'declare valid name.member.member'"
            if NotMe.varRef.accessors Then Me.sayErr("declare valid: expected accesor chain. Example: 'declare valid name.member.member'")
            'if .opt(':')
            if Me.opt(":") Then
            
                '.type = .req(TypeDeclaration) //optional type
                Me.type = Me.req(TypeDeclaration)
            
            End if
            
        
        
        case "name"
        
            '.specifier = .req('affinity')
            Me.specifier = Me.req("affinity")
            '.names = .reqSeparatedList(VariableDecl,',')
            Me.names = Me.reqSeparatedList(VariableDecl, ",")
            'for each varDecl in .names
            For Each varDecl in Me.names
            
               'if (varDecl.type and varDecl.type isnt 'any') or varDecl.assignedValue
               if (varDecl.type AndAlso varDecl.type <> "any") OrElse varDecl.assignedValue Then
               
                  '.sayErr "declare name affinity: expected 'name,name,...'"
                  Me.sayErr("declare name affinity: expected 'name,name,...'")
               
               End if
               
            Next'  each in Me.names
            
        
        
        case "var"
        
            '.names = .reqSeparatedList(VariableDecl,',')
            Me.names = Me.reqSeparatedList(VariableDecl, ",")
            'for each varDecl in .names
            For Each varDecl in Me.names
            
               'if varDecl.assignedValue
               if varDecl.assignedValue Then
               
                  '.sayErr "declare var. Cannot assign value in .interface.md file."
                  Me.sayErr("declare var. Cannot assign value in .interface.md file.")
               
               End if
               
            Next'  each in Me.names
            
        
        
        case "on"
        
            '.name = .req('IDENTIFIER')
            Me.name = Me.req("IDENTIFIER")
            '.names = .reqSeparatedList(VariableDecl,',')
            Me.names = Me.reqSeparatedList(VariableDecl, ",")
        
        

        '//end cases

        'return
        return
      end function
    
    end class 'DeclareStatement


'## DefaultAssignment

'`DefaultAssignment: default AssignmentStatement`

'It is a common pattern in javascript to use a object parameters (named "options")
'to pass misc options to functions.

'Litescript provide a 'default' construct as syntax sugar for this common pattern

'The 'default' construct is formed as an ObjectLiteral assignment,
'but only the 'undfined' properties of the object will be assigned.


'Example:
'
'
'    function theApi(object,options,callback)
'
'      default options =
'        logger: console.log
'        encoding: 'utf-8'
'        throwErrors: true
'        debug:
'          enabled: false
'          level: 2
'      end default
'
'      ...function body...
'
'    end function
'is equivalent to js's:
'
'
'    function theApi(object,options,callback) {
'
'        //defaults
'        if (!options) options = {};
'        if (options.logger===undefined) options.logger = console.log;
'        if (options.encoding===undefined) options.encoding = 'utf-8';
'        if (options.throwErrors===undefined) options.throwErrors=true;
'        if (!options.debug) options.debug = {};
'        if (options.debug.enabled===undefined) options.debug.enabled=false;
'        if (options.debug.level===undefined) options.debug.level=2;
'
'        ...function body...
'    }

    '    public class DefaultAssignment extends ASTBase
    ' constructor
    Class DefaultAssignment
    Inherits ASTBase
        Public Property assignment as AssignmentStatement' mainType: AssignmentStatement  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'default'
        Me.req("default")
        '.lock()
        Me.lock()

        '.assignment = .req(AssignmentStatement)
        Me.assignment = Me.req(AssignmentStatement)
      end function
    
    end class 'DefaultAssignment



'## End Statement

'`EndStatement: end (IDENTIFIER)* NEWLINE`

'`end` is an **optional** end-block marker to ease code reading.
'It marks the end of code blocks, and can include extra tokens referencing the construction
'closed. (in the future) This references will be cross-checked, to help redude subtle bugs
'by checking that the block ending here is the intended one.

'If it's not used, the indentation determines where blocks end ()

'Example: `end if` , `end loop`, `end for each item`

'Usage Examples:
'
'
'    if a is 3 and b is 5
'      print "a is 3"
'      print "b is 5"
'    end if
'
'    loop while a < 10
'      a++
'      b++
'    end loop

    '    public class EndStatement extends ASTBase
    ' constructor
    Class EndStatement
    Inherits ASTBase
        Public Property references as Array' mainType: Array  ' itemType: String
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'end'
        Me.req("end")

        '.lock()
        Me.lock()
        '.references=[]
        Me.references = new ArrayList

        'var block:ASTBase
        Dim block = Nothing
        'if .parent.parent is instanceof Body or .parent.parent is instanceof Module
        if TypeOf Me.parent.parent is Body OrElse TypeOf Me.parent.parent is Module Then
        
            'block = .parent.parent
            block = Me.parent.parent
        
        End if
        'if no block
        if Notblock Then
        
            '.lexer.throwErr "'end' statement found outside a block"
            Me.lexer.throwErr("'end' statement found outside a block")
        
        End if
        'var expectedIndent = block.indent or 4
        Dim expectedIndent = block.indent OrElse 4
        'if .indent isnt expectedIndent
        if Me.indent <> expectedIndent Then
        
            '.lexer.throwErr "'end' statement misaligned indent: #{.indent}. Expected #{expectedIndent} to close block started at line #{block.sourceLineNum}"
            Me.lexer.throwErr("'end' statement misaligned indent: " + Me.indent + ". Expected " + expectedIndent + " to close block started at line " + block.sourceLineNum)
        
        End if


'The words after `end` are just 'loose references' to the block intended to be closed
'We pick all the references up to EOL (or EOF)

        'while not .opt('NEWLINE','EOF')
        Do whileNot(Me.opt("NEWLINE", "EOF"))
        

'Get optional identifier reference
'We save `end` references, to match on block indentation,
'for Example: `end for` indentation must match a `for` statement on the same indent

            'if .lexer.token.type is 'IDENTIFIER'
            if Me.lexer.token.type = "IDENTIFIER" Then
            
              '.references.push(.lexer.token.value)
              Me.references.push(Me.lexer.token.value)
            
            End if

            '.lexer.nextToken
            Me.lexer.nextToken()
        
        Loop
        
      end function
    
    end class 'EndStatement

        '#end loop


'## YieldExpression

'`YieldExpression: yield until asyncFnCall-VariableRef`
'`YieldExpression: yield parallel map array-Expression asyncFnCall-VariableRef`

'`yield until` expression calls a 'standard node.js async function'
'and `yield` execution to the caller function until the async completes (callback).

'A 'standard node.js async function' is an async function
'with the last parameter = callback(err,data)

'The yield-wait is implemented by exisiting lib 'nicegen'.

'Example: `contents = yield until fs.readFile 'myFile.txt','utf8'`

    'public class YieldExpression extends ASTBase
    ' constructor
    Class YieldExpression
    Inherits ASTBase
        Public Property specifier as Object
          Public Property fnCall as Object
          Public Property arrExpression as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'yield'
        Me.req("yield")
        '.specifier = .req('until','parallel')
        Me.specifier = Me.req("until", "parallel")

        '.lock()
        Me.lock()

        'if .specifier is 'until'
        if Me.specifier = "until" Then
        

            '.fnCall = .req(FunctionCall)
            Me.fnCall = Me.req(FunctionCall)
        
        'if .specifier is 'until'
        
        else
        

            '.req 'map'
            Me.req("map")
            '.arrExpression = .req(Expression)
            Me.arrExpression = Me.req(Expression)
            '.fnCall = .req(FunctionCall)
            Me.fnCall = Me.req(FunctionCall)
        
        End if
        
      end function
    
    end class 'YieldExpression


'FunctionCall
'------------

'`FunctionCall: VariableRef ["("] (FunctionArgument,) [")"]`

    'public class FunctionCall extends ASTBase
    ' constructor
    Class FunctionCall
    Inherits ASTBase
        Public Property varRef as VariableRef' mainType: VariableRef  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse (options)
        'declare valid .parent.preParsedVarRef
        

'Check for VariableRef. - can include (...) FunctionAccess

        'if .parent.preParsedVarRef #VariableRef already parsed
        if Me.parent.preParsedVarRef Then
        
          '.varRef = .parent.preParsedVarRef #use it
          Me.varRef = Me.parent.preParsedVarRef
        
        'if .parent.preParsedVarRef #VariableRef already parsed
        
        else
        
          '.varRef = .req(VariableRef)
          Me.varRef = Me.req(VariableRef)
        
        End if

'if the last accessor is function call, this is already a FunctionCall

        '//debug "#{.varRef.toString()} #{.varRef.executes?'executes':'DO NOT executes'}"

        'if .varRef.executes
        if Me.varRef.executes Then
        
            'return #already a function call
            return
        
        End if

        'if .lexer.token.type is 'EOF'
        if Me.lexer.token.type = "EOF" Then
        
            'return // no more tokens
            return
        
        End if

'alllow a indented block to be parsed as fn call arguments

        'if .opt('NEWLINE') // if end of line, check next line
        if Me.opt("NEWLINE") Then
        
            'var nextLineIndent = .lexer.indent //save indent
            Dim nextLineIndent = Me.lexer.indent
            '.lexer.returnToken() //return NEWLINE
            Me.lexer.returnToken()
            '// check if next line is indented (with respect to Statement (parent))
            'if nextLineIndent <= .parent.indent // next line is not indented
            if nextLineIndent <= Me.parent.indent Then
            
                  '// assume this is just a fn call w/o parameters
                  'return
                  return
            
            End if
            
        
        End if

'else, get parameters, add to varRef as FunctionAccess accessor,

        'var functionAccess = new FunctionAccess(.varRef)
        Dim functionAccess = new FunctionAccess(Me.varRef)
        'functionAccess.args = functionAccess.reqSeparatedList(FunctionArgument,",")
        functionAccess.args = functionAccess.reqSeparatedList(FunctionArgument, ",")
        'if .lexer.token.value is '->' #add last parameter: callback function (comma before -> is optional)
        if Me.lexer.token.value = "->" Then
        
            'functionAccess.args.push .req(FunctionArgument)
            functionAccess.args.push(Me.req(FunctionArgument))
        
        End if

        '.varRef.addAccessor functionAccess
        Me.varRef.addAccessor(functionAccess)
      end function
    
    end class 'FunctionCall


'## CaseStatement

'`CaseStatement: case [VariableRef] [instance of] NEWLINE (when (Expression,) Body)* [else Body]`

'Similar syntax to ANSI-SQL 'CASE', and ruby's 'case'
'but it is a "statement" not a expression

'Examples:
'
'
'    case b
'      when 2,4,6:
'        print 'even'
'      when 1,3,5:
'        print 'odd'
'      else
'        print 'idk'
'    end
'
'    // case instance of
'    case b instance of
'
'      when VarStatement:
'        print 'variables #{b.list}'
'
'      when AppendToDeclaration:
'        print 'it is append to #{b.varRef}'
'
'      when NamespaceDeclaration:
'        print 'namespace #{b.name}'
'
'      when ClassDeclaration:
'        print 'a class, extends #{b.varRefSuper}'
'
'      else
'        print 'unexpected class'
'
'    end
'
'    // case when TRUE
'    var result
'    case
'        when a is 3 or b < 10:
'            result = 'option 1'
'        when b >= 10 or a<0 or c is 5:
'            result= 'option 2'
'        else
'            result = 'other'
'    end
'

    '    public class CaseStatement extends ASTBase
    ' constructor
    Class CaseStatement
    Inherits ASTBase
        Public Property varRef as VariableRef' mainType: VariableRef  
      
          Public Property isInstanceof as Boolean' mainType: Boolean  
      
          Public Property cases as Array' mainType: Array  ' itemType: WhenSection
      
          Public Property elseBody as Body' mainType: Body  
      
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.req 'case'
        Me.req("case")
        '.lock
        Me.lock()

        '.varRef = .opt(VariableRef)
        Me.varRef = Me.opt(VariableRef)

        '.isInstanceof = .opt('instance','instanceof') //case foo instance of
        Me.isInstanceof = Me.opt("instance", "instanceof")
        'if .isInstanceof is 'instance', .opt('of')
        if Me.isInstanceof = "instance" Then Me.opt("of")

        '.req('NEWLINE')
        Me.req("NEWLINE")

        '.cases=[]
        Me.cases = new ArrayList
        'while .opt(WhenSection) into var whenSection
        Dim whenSection as Object
        Do whileAssign(whenSection,Me.opt(WhenSection))
        
            '.cases.push whenSection
            Me.cases.push(whenSection)
        
        Loop

        'if .cases.length is 0, .sayErr 'no "when" sections found for "case" construction'
        if Me.cases.length = 0 Then Me.sayErr("no "when" sections found for "case" construction")

        'if .opt('else')
        if Me.opt("else") Then
        
            '.elseBody = .req(Body)
            Me.elseBody = Me.req(Body)
        
        End if
        
      end function
    
    end class 'CaseStatement

    '    public helper class WhenSection extends ASTBase
    ' constructor
    Class WhenSection
    Inherits ASTBase
        Public Property expressions as Array' mainType: Array  ' itemType: Expression
        
            Public Property body as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
        ' ---------------------------
        Public Function parse ()

            '.req 'when'
            Me.req("when")
            '.lock
            Me.lock()
            '.expressions = .reqSeparatedList(Expression, ",",":")
            Me.expressions = Me.reqSeparatedList(Expression, ",", ":")

            'if .lexer.token.type is 'NEWLINE'
            if Me.lexer.token.type = "NEWLINE" Then
            
                '.body = .req(Body) //indented body block
                Me.body = Me.req(Body)
            
            'if .lexer.token.type is 'NEWLINE'
            
            else
            
                '.body = .req(SingleLineBody)
                Me.body = Me.req(SingleLineBody)
            
            End if
            
        end function
    
    end class 'WhenSection


    '    public helper class TypeDeclaration extends ASTBase
    ' constructor
    Class TypeDeclaration
    Inherits ASTBase
        Public Property mainType as Object
          Public Property keyType as Object
          Public Property itemType as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

'parse type declaration:

  'function [(VariableDecl,)]
  'type-IDENTIFIER [array]
  '[array of] type-IDENTIFIER
  'map type-IDENTIFIER to type-IDENTIFIER

        'if .opt('function','Function') #function as type
        if Me.opt("function", "Function") Then
        
            '.lock
            Me.lock()
            '.mainType= new VariableRef(this, 'Function')
            Me.mainType = new VariableRef(Me, "Function")
            'if .lexer.token.value is '(', .parseAccessors
            if Me.lexer.token.value = "(" Then Me.parseAccessors()
            'return
            return
        
        End if

'check for 'array', e.g.: `var list : array of String`

        'if .opt('array','Array')
        if Me.opt("array", "Array") Then
        
            '.lock
            Me.lock()
            '.mainType = 'Array'
            Me.mainType = "Array"
            'if .opt('of')
            if Me.opt("of") Then
            
                '.itemType = .req(VariableRef) #reference to an existing class
                Me.itemType = Me.req(VariableRef)
                '//auto-capitalize core classes
                'declare .itemType:VariableRef
                
                '.itemType.name = autoCapitalizeCoreClasses(.itemType.name)
                Me.itemType.name = autoCapitalizeCoreClasses(Me.itemType.name)
            
            End if
            'end if
            'return
            
            'return
            return
        
        End if

'Check for 'map', e.g.: `var list : map string to Statement`

        '.mainType = .req(VariableRef) #reference to an existing class
        Me.mainType = Me.req(VariableRef)
        '.lock
        Me.lock()
        '//auto-capitalize core classes
        'declare .mainType:VariableRef
        
        '.mainType.name = autoCapitalizeCoreClasses(.mainType.name)
        Me.mainType.name = autoCapitalizeCoreClasses(Me.mainType.name)

        'if .mainType.name is 'Map'
        if Me.mainType.name = "Map" Then
        
            '.parent.isMap = true
            Me.parent.isMap = true
            '.extraInfo = 'map [type] to [type]' //extra info to show on parse fail
            Me.extraInfo = "map [type] to [type]"
            '.keyType = .req(VariableRef) #type for KEYS: reference to an existing class
            Me.keyType = Me.req(VariableRef)
            '//auto-capitalize core classes
            'declare .keyType:VariableRef
            
            '.keyType.name = autoCapitalizeCoreClasses(.keyType.name)
            Me.keyType.name = autoCapitalizeCoreClasses(Me.keyType.name)
            '.req('to')
            Me.req("to")
            '.itemType = .req(VariableRef) #type for values: reference to an existing class
            Me.itemType = Me.req(VariableRef)
            '#auto-capitalize core classes
            'declare .itemType:VariableRef
            
            '.itemType.name = autoCapitalizeCoreClasses(.itemType.name)
            Me.itemType.name = autoCapitalizeCoreClasses(Me.itemType.name)
        
        'if .mainType.name is 'Map'
        
        else
        
            '#check for 'type array', e.g.: `var list : string array`
            'if .opt('Array','array')
            if Me.opt("Array", "array") Then
            
                '.itemType = .mainType #assign read mainType as sub-mainType
                Me.itemType = Me.mainType
                '.mainType = 'Array' #real type
                Me.mainType = "Array"
            
            End if
            
        
        End if
        
      end function
      ' ---------------------------
      Public Function toString ()
        'return .mainType
        return Me.mainType
      end function
    
    end class 'TypeDeclaration


'##Statement

'A `Statement` is an imperative statment (command) or a control construct.

'The `Statement` node is a generic container for all previously defined statements.


'The generic `Statement` is used to define `Body: (Statement;)`, that is,
'**Body** is a list of semicolon (or NEWLINE) separated **Statements**.

'Grammar:
'```
'Statement: [Adjective]* (ClassDeclaration|FunctionDeclaration
 '|IfStatement|ForStatement|WhileUntilLoop|DoLoop
 '|AssignmentStatement
 '|LoopControlStatement|ThrowStatement
 '|TryCatch|ExceptionBlock
 '|ReturnStatement|PrintStatement|DoNothingStatement)

'Statement: ( AssignmentStatement | fnCall-VariableRef [ ["("] (Expression,) [")"] ] )
'```

    'public class Statement extends ASTBase
    ' constructor
    Class Statement
    Inherits ASTBase
        Public Property adjectives as Array' mainType: Array  ' itemType: String
      =new ArrayList
      
          Public Property specific as ASTBase' mainType: ASTBase  
      
          Public Property preParsedVarRef as Object
          Public Property intoVars as Object
          Public Property lastSourceLineNum as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        'var key
        Dim key = Nothing

        '#debug show line and tokens
        'logger.debug ""
        logger.debug("")
        '.lexer.infoLine.dump()
        Me.lexer.infoLine.dump()

'First, fast-parse the statement by using a table.
'We look up the token (keyword) in **StatementsDirect** table, and parse the specific AST node

        'key = .lexer.token.value
        key = Me.lexer.token.value
        '.specific = .parseDirect(key, StatementsDirect)
        Me.specific = Me.parseDirect(key, StatementsDirect)

        'if no .specific
        if NotMe.specific Then
        

'If it was not found, try optional adjectives (zero or more).
'Adjectives are: `(export|default|public|generator|shim|helper)`.

            'while .opt('public','export','only','nice','generator','shim','helper','global') into var adj
            Dim adj as Object
            Do whileAssign(adj,Me.opt("public", "export", "only", "nice", "generator", "shim", "helper", "global"))
            
                'if adj is 'public', adj='export' #'public' is alias for 'export'
                if adj = "public" Then adj = "export"
                '.adjectives.push adj
                Me.adjectives.push(adj)
            
            Loop

'Now re-try fast-parse

            'key = .lexer.token.value
            key = Me.lexer.token.value
            '.specific = .parseDirect(key, StatementsDirect)
            Me.specific = Me.parseDirect(key, StatementsDirect)

'Last possibilities are: `FunctionCall` or `AssignmentStatement`
'both start with a `VariableRef`:

'(performance) **require** & pre-parse the VariableRef.
'Then we require a AssignmentStatement or FunctionCall

            'if no .specific
            if NotMe.specific Then
            

                'key = 'varref'
                key = "varref"
                '.preParsedVarRef = .req(VariableRef)
                Me.preParsedVarRef = Me.req(VariableRef)
                '.specific = .req(AssignmentStatement,FunctionCall)
                Me.specific = Me.req(AssignmentStatement, FunctionCall)
                '.preParsedVarRef = undefined #clear
                Me.preParsedVarRef = undefined
            
            End if
            
        
        End if


        'end if - statement parse tries

'If we reached here, we have parsed a valid statement.
'remember where the full statment ends (multiline statements)

        '.lastSourceLineNum = .lexer.last.sourceLineNum
        

'If we reached here, we have parsed a valid statement.
'remember where the full statment ends (multiline statements)

        '.lastSourceLineNum = .lexer.last.sourceLineNum
        Me.lastSourceLineNum = Me.lexer.last.sourceLineNum
        'if .lastSourceLineNum<.sourceLineNum, .lastSourceLineNum = .sourceLineNum
        if Me.lastSourceLineNum < Me.sourceLineNum Then Me.lastSourceLineNum = Me.sourceLineNum

'store keyword of specific statement

        'key = key.toLowerCase()
        key = key.toLowerCase()
        '.keyword = key
        Me.keyword = key

'Check valid combinations adjective-statement

        'for each adjective in .adjectives
        For Each adjective in Me.adjectives
        

              'var valid:string array = validCombinations.get(adjective) or ['-*none*-']
              Dim valid = validCombinations.get(adjective) OrElse new ArrayList From {"-*none*-"}
              'if key not in valid, .throwError "'#{adjective}' can only apply to #{valid.join('|')} not to '#{key}'"
              if Not (valid.Contains(key)) Then Me.throwError("'" + adjective + "' can only apply to " + (valid.join("|")) + " not to '" + key + "'")
        Next'  each in Me.adjectives

        'end for

'Check valid adjectives combinations

        'if .hasAdjective('global export'), .sayErr "cannot combine 'global' with 'public|export' choose one"
        

'Check valid adjectives combinations

        'if .hasAdjective('global export'), .sayErr "cannot combine 'global' with 'public|export' choose one"
        if Me.hasAdjective("global export") Then Me.sayErr("cannot combine 'global' with 'public|export' choose one")
      end function
    
    end class 'Statement


'#### Module level var: valid combinations adjective-statement

    'var validCombinations = map
          'export: ['class','namespace','function','var']
          'only: ['class','namespace']
          'generator: ['function','method']
          'nice: ['function','method']
          'shim: ['function','method','import']
          'helper:  ['function','method','class','namespace']
          'global: ['declare','class','namespace','function','var']


    '    append to class ASTBase
    Dim validCombinations = new Dictionary(Of String,Object) from {
        {export,new ArrayList From {"class", "namespace", "function", "var"}
          }
        , {only,new ArrayList From {"class", "namespace"}
          }
        , {generator,new ArrayList From {"function", "method"}
          }
        , {nice,new ArrayList From {"function", "method"}
          }
        , {shim,new ArrayList From {"function", "method", "import"}
          }
        , {helper,new ArrayList From {"function", "method", "class", "namespace"}
          }
        , {global,new ArrayList From {"declare", "class", "namespace", "function", "var"}
          }
          }


    '    append to class ASTBase
    Partial Class ASTBase
    

      '      helper method hasAdjective(names:string) returns boolean
      ' ---------------------------
      Public Function hasAdjective (names)
'To check if a statement has one or more adjectives.
'We assume .parent is Grammar.Statement

        'var stat:Statement = this.constructor is Statement? this else .getParent(Statement)
        Dim stat = Me.constructor = Statement ? Me : Me.getParent(Statement)
        'if no stat, .throwError "[#{.constructor.name}].hasAdjective('#{names}'): can't find a parent Statement"
        if Notstat Then Me.throwError("[" + Me.constructor.name + "].hasAdjective('" + names + "'): can't find a parent Statement")

        'var allToSearch = names.split(" ")
        Dim allToSearch = names.split(" ")
        'for each name in allToSearch
        For Each name in allToSearch
        
            'if no name in stat.adjectives, return false
            if Not(stat.adjectives.Contains(name)) Then return false
        Next'  each in allToSearch

        'return true //if all requested are adjectives
        return true
      end function
      
    
    End Class 'partial

'## Body

'`Body: (Statement;)`

'Body is a semicolon-separated list of statements (At least one)

'`Body` is used for "Module" body, "class" body, "function" body, etc.
'Anywhere a list of semicolon separated statements apply.

'Body parser expects a [NEWLINE] and then a indented list of statements

    'public class Body extends ASTBase
    ' constructor
    Class Body
    Inherits ASTBase
        Public Property statements as Array' mainType: Array  ' itemType: Statement
      
          Public Property endSourceLineNum as Object
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.endSourceLineNum = .sourceLineNum //default value - store to generate accurate SourceMaps (js)
        Me.endSourceLineNum = Me.sourceLineNum

        'if .lexer.interfaceMode
        if Me.lexer.interfaceMode Then
        
            'if .parent isnt instance of ClassDeclaration
            if Not (TypeOf Me.parent is ClassDeclaration) Then
            
                'return //"no 'Bodys' expected on interface.md file except for: class, append to and namespace
                return
            
            End if
            
        
        End if

        'if .lexer.token.type isnt 'NEWLINE'
        if Me.lexer.token.type <> "NEWLINE" Then
        
            '.lexer.sayErr "found #{.lexer.token} but expected NEWLINE and indented body"
            Me.lexer.sayErr("found " + Me.lexer.token + " but expected NEWLINE and indented body")
        
        End if

'We use the generic ***ASTBase.reqSeparatedList*** to get a list of **Statement** symbols,
'*semicolon* separated or in freeForm mode: one statement per line, closed when indent changes.

        '.statements = .reqSeparatedList(Statement,";")
        Me.statements = Me.reqSeparatedList(Statement, ";")

        '# store "endSourceLineNum".
        '.endSourceLineNum = .lexer.sourceLineNum
        Me.endSourceLineNum = Me.lexer.sourceLineNum
      end function
      ' ---------------------------
      Public Function validate ()

'this method check all the body statements againts a valid-list (arguments)

        'var validArray = arguments.toArray()
        Dim validArray = arguments.toArray()

        'for each stm in .statements
        For Each stm in Me.statements
        if Not (new ArrayList From {EndStatement, CompilerStatement}
            .Contains(stm.specific.constructor)) Then
        

                'if stm.specific.constructor not in validArray
                if Not (validArray.Contains(stm.specific.constructor)) Then
                
                    'stm.sayErr "a [#{stm.specific.constructor.name}] is not valid in the body of a [#{.parent.constructor.name}]"
                    stm.sayErr("a [" + stm.specific.constructor.name + "] is not valid in the body of a [" + Me.parent.constructor.name + "]")
                
                End if
                
        End if
        Next'  each in Me.statements
        
      end function
    
    end class 'Body

'## Single Line Body

'This construction is used when only one statement is expected, and on the same line.
'It is used by `IfStatement: if conditon-Expression (','|then) *SingleLineBody*`
'It is also used for the increment statemenf in for-while loops:`for x=0, while x<10 [,SingleLineBody]`

'normally: ReturnStatement, ThrowStatement, PrintStatement, AssignmentStatement

    'public class SingleLineBody extends Body
    ' constructor
    Class SingleLineBody
    Inherits Body
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

        '.statements = .reqSeparatedList(Statement,";",'NEWLINE')
        Me.statements = Me.reqSeparatedList(Statement, ";", "NEWLINE")
      end function
    
    end class 'SingleLineBody


'## Module

'The `Module` represents a complete source file.

    'public class Module extends ASTBase
    ' constructor
    Class Module
    Inherits ASTBase
        Public Property body as Object
          Public Property dependencyTreeLevel as Object=0
          Public Property dependencyTreeLevelOrder as Object=0
          Public Property importOrder as Object=0
    
    Sub New() 'default constructor
    ' default constructor: call super.constructor
        MyBase.New(
      ' ---------------------------
      Public Function parse ()

'We start by locking. There is no other construction to try,
'if Module.parse() fails we abort compilation.

          '.lock()
          Me.lock()

'Get Module body: Statements, separated by NEWLINE|';' closer:'EOF'

          '.body = new Body(this)
          Me.body = new Body(Me)

          '.body.statements = .optFreeFormList(Statement,';','EOF')
          Me.body.statements = Me.optFreeFormList(Statement, ";", "EOF")
      end function
    
    end class 'Module

      '#end Module parse


'----------------------------------------

'Table-based (fast) Statement parsing
'------------------------------------

'This a extension to PEGs.
'To make the compiler faster and easier to debug, we define an
'object with name-value pairs: `"keyword" : AST node class`

'We look here for fast-statement parsing, selecting the right AST node to call `parse()` on
'based on `token.value`. (instead of parsing by ordered trial & error)

'This table makes a direct parsing of almost all statements, thanks to a core definition of LiteScript:
'Anything standing alone in it's own line, its an imperative statement (it does something, it produces effects).

    'var StatementsDirect = map
      ''class': ClassDeclaration
      ''Class': ClassDeclaration
      ''append': AppendToDeclaration
      ''Append': AppendToDeclaration
      ''function': FunctionDeclaration
      ''constructor': ConstructorDeclaration
      ''properties': PropertiesDeclaration
      ''namespace': NamespaceDeclaration
      ''method': MethodDeclaration
      ''var': VarStatement
      ''let': VarStatement
      ''default': DefaultAssignment
      ''if': IfStatement
      ''when': IfStatement
      ''case': CaseStatement
      ''for':ForStatement
      ''while':WhileUntilLoop
      ''until':WhileUntilLoop
      ''do':[DoNothingStatement,DoLoop]
      ''break':LoopControlStatement
      ''continue':LoopControlStatement
      ''end':EndStatement
      ''return':ReturnStatement
      ''with':WithStatement
      ''print':PrintStatement
      ''throw':ThrowStatement
      ''raise':ThrowStatement
      ''fail':ThrowStatement
      ''try':TryCatch
      ''exception':ExceptionBlock
      ''Exception':ExceptionBlock
      ''debugger':DebuggerStatement
      ''declare':DeclareStatement
      ''import':ImportStatement
      ''delete':DeleteStatement
      ''compile':CompilerStatement
      ''compiler':CompilerStatement
      ''yield':YieldExpression


'##### Helpers

    'export helper function autoCapitalizeCoreClasses(name:string) returns String
    Dim StatementsDirect = new Dictionary(Of String,Object) from {
        {"class",ClassDeclaration}
        , {"Class",ClassDeclaration}
        , {"append",AppendToDeclaration}
        , {"Append",AppendToDeclaration}
        , {"function",FunctionDeclaration}
        , {"constructor",ConstructorDeclaration}
        , {"properties",PropertiesDeclaration}
        , {"namespace",NamespaceDeclaration}
        , {"method",MethodDeclaration}
        , {"var",VarStatement}
        , {"let",VarStatement}
        , {"default",DefaultAssignment}
        , {"if",IfStatement}
        , {"when",IfStatement}
        , {"case",CaseStatement}
        , {"for",ForStatement}
        , {"while",WhileUntilLoop}
        , {"until",WhileUntilLoop}
        , {"do",new ArrayList From {DoNothingStatement, DoLoop}
      }
        , {"break",LoopControlStatement}
        , {"continue",LoopControlStatement}
        , {"end",EndStatement}
        , {"return",ReturnStatement}
        , {"with",WithStatement}
        , {"print",PrintStatement}
        , {"throw",ThrowStatement}
        , {"raise",ThrowStatement}
        , {"fail",ThrowStatement}
        , {"try",TryCatch}
        , {"exception",ExceptionBlock}
        , {"Exception",ExceptionBlock}
        , {"debugger",DebuggerStatement}
        , {"declare",DeclareStatement}
        , {"import",ImportStatement}
        , {"delete",DeleteStatement}
        , {"compile",CompilerStatement}
        , {"compiler",CompilerStatement}
        , {"yield",YieldExpression}
      }


'##### Helpers

    'export helper function autoCapitalizeCoreClasses(name:string) returns String
    ' ---------------------------
    function autoCapitalizeCoreClasses(name)
      '#auto-capitalize core classes when used as type annotations
      'if name in ['string','array','number','object','function','boolean','map']
      if new ArrayList From {"string", "array", "number", "object", "function", "boolean", "map"}
      .Contains(name) Then
      
        'return "#{name.slice(0,1).toUpperCase()}#{name.slice(1)}"
        return "" + (name.slice(0, 1).toUpperCase()) + (name.slice(1))
      
      End if
      'return name
      return name
    end function


    '    append to class ASTBase
    Partial Class ASTBase
    
      'properties
            'isMap: boolean
          Public Property isMap as Boolean' mainType: Boolean  
      
      
    
    End Class 'partial' -----------
' Module code
' -----------

    'end Operand


'## Oper

'```
'Oper: ('~'|'&'|'^'|'|'|'>>'|'<<'
        '|'*'|'/'|'+'|'-'|mod
        '|instance of|instanceof
        '|'>'|'<'|'>='|'<='
        '|is|'==='|isnt|is not|'!=='
        '|and|but|or
        '|[not] in
        '|(has|hasnt) property
        '|? true-Expression : false-Expression)`
'```

'An Oper sits between two Operands ("Oper" is a "Binary Operator",
'different from *UnaryOperators* which optionally precede a Operand)

'If an Oper is found after an Operand, a second Operand is expected.

'Operators can include:
'* arithmetic operations "*"|"/"|"+"|"-"
'* boolean operations "and"|"or"
'* `in` collection check.  (js: `indexOx()>=0`)
'* instance class checks   (js: instanceof)
'* short-if ternary expressions ? :
'* bit operations (|&)
'* `has property` object property check (js: 'propName in object')

    '    public class Oper extends ASTBase
    
end module
